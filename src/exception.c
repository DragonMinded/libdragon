/**
 * @file exception.c
 * @brief Exception Handler
 * @ingroup exceptions
 */
#include "exception.h"
#include "console.h"
#include "n64sys.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

/**
 * @defgroup exceptions Exception Handler
 * @ingroup lowlevel
 * @brief Handle hardware-generated exceptions.
 *
 * The exception handler traps exceptions generated by hardware.  This could
 * be an invalid instruction or invalid memory access exception or it could
 * be a reset exception.  In both cases, a handler registered with 
 * #register_exception_handler will be passed information regarding the
 * exception type and relevant registers.
 *
 * @{
 */

/** @brief Exception handler currently registered with exception system */
static void (*__exception_handler)(exception_t*) = exception_default_handler;
/** @brief Base register offset as defined by the interrupt controller */
extern const void* __baseRegAddr;

/**
 * @brief Register an exception handler to handle exceptions
 *
 * @param[in] cb
 *            Callback function to call when exceptions happen
 */
void register_exception_handler( void (*cb)(exception_t*))
{
	__exception_handler = cb;
}

/**
 * We keep a function outside the exception handler so that the interrupts are
 * re-enabled when we return from it. console_render does not work without
 * interrupts being enabled. display_lock will lock the system if called
 * without the VI interrupt enabled, thus rendering the system unable to render
 * the console.
 */
static void exception_halt() {
	console_render();
	abort();
}

void exception_default_handler(exception_t* ex) {
	// We need to return from the ex handler to gracefully restore interrupt
	// state so that we can continue using interrupt dependent functionalities.
	C0_WRITE_EPC(&exception_halt);

	uint32_t cr = ex->regs->cr;
	uint32_t sr = ex->regs->sr;
	uint32_t fcr31 = ex->regs->fc31;

	switch(ex->code) {
		case EXCEPTION_CODE_STORE_ADDRESS_ERROR:
		case EXCEPTION_CODE_LOAD_I_ADDRESS_ERROR:
		case EXCEPTION_CODE_TLB_MODIFICATION:
		case EXCEPTION_CODE_TLB_STORE_MISS:
		case EXCEPTION_CODE_TLB_LOAD_I_MISS:
		case EXCEPTION_CODE_COPROCESSOR_UNUSABLE:
		break;
		case EXCEPTION_CODE_FLOATING_POINT:
			// Clear FP interrupt cause bits so that it is not retriggered when we return to exception_halt
			C1_WRITE_FCR31(
				C1_FCR31() & ~(
					C1_CAUSE_INEXACT_OP |
					C1_CAUSE_UNDERFLOW |
					C1_CAUSE_OVERFLOW |
					C1_CAUSE_DIV_BY_0 |
					C1_CAUSE_INVALID_OP |
					C1_CAUSE_NOT_IMPLEMENTED
				)
			);
		break;
		case EXCEPTION_CODE_WATCH:
		case EXCEPTION_CODE_ARITHMETIC_OVERFLOW:
		case EXCEPTION_CODE_TRAP:
		case EXCEPTION_CODE_I_BUS_ERROR:
		case EXCEPTION_CODE_D_BUS_ERROR:
		case EXCEPTION_CODE_SYS_CALL:
		case EXCEPTION_CODE_BREAKPOINT:
		case EXCEPTION_CODE_INTERRUPT:
		default:
		break;
	}

	console_set_render_mode(RENDER_MANUAL);
	console_clear();

	fprintf(stdout, "**************************************************************************");
	fprintf(stdout, "%s exception at PC:%08lX\n", ex->info, ex->regs->epc);

	fprintf(stdout, "cr:%08lX (COP:%1lu BD:%lu)\n", cr,  C0_GET_CAUSE_CE(cr), cr & C0_CAUSE_BD);
	fprintf(stdout, "sr:%08lX FCR31:%08X BVAdr:%08lX \n", sr, (unsigned int)fcr31, C0_READ_BADVADDR());
	fprintf(stdout, "--------------------------------------------------------------------------");
	fprintf(stdout, "FPU     IOP UND OVE DV0 INV  NI  | INTs    sw0 sw1 ex0 ex1 ex2 ex3 ex4  tm");
	fprintf(stdout, "Cause   %3u %3u %3u %3u %3u %3u  | Cause   %3u %3u %3u %3u %3u %3u %3u %3u",
		(bool)(fcr31 & C1_CAUSE_INEXACT_OP),
		(bool)(fcr31 & C1_CAUSE_UNDERFLOW),
		(bool)(fcr31 & C1_CAUSE_OVERFLOW),
		(bool)(fcr31 & C1_CAUSE_DIV_BY_0),
		(bool)(fcr31 & C1_CAUSE_INVALID_OP),
		(bool)(fcr31 & C1_CAUSE_NOT_IMPLEMENTED),

		(bool)(cr & C0_INTERRUPT_0),
		(bool)(cr & C0_INTERRUPT_1),
		(bool)(cr & C0_INTERRUPT_2),
		(bool)(cr & C0_INTERRUPT_3),
		(bool)(cr & C0_INTERRUPT_4),
		(bool)(cr & C0_INTERRUPT_5),
		(bool)(cr & C0_INTERRUPT_6),
		(bool)(cr & C0_INTERRUPT_7)
	);
	fprintf(stdout, "Enabled %3u %3u %3u %3u %3u   -  | MASK    %3u %3u %3u %3u %3u %3u %3u %3u",
		(bool)(fcr31 & C1_ENABLE_INEXACT_OP),
		(bool)(fcr31 & C1_ENABLE_UNDERFLOW),
		(bool)(fcr31 & C1_ENABLE_OVERFLOW),
		(bool)(fcr31 & C1_ENABLE_DIV_BY_0),
		(bool)(fcr31 & C1_ENABLE_INVALID_OP),

		(bool)(sr & C0_INTERRUPT_0),
		(bool)(sr & C0_INTERRUPT_1),
		(bool)(sr & C0_INTERRUPT_2),
		(bool)(sr & C0_INTERRUPT_3),
		(bool)(sr & C0_INTERRUPT_4),
		(bool)(sr & C0_INTERRUPT_5),
		(bool)(sr & C0_INTERRUPT_6),
		(bool)(sr & C0_INTERRUPT_7)
	);

	fprintf(stdout, "Flags   %3u %3u %3u %3u %3u   -  |\n",
		(bool)(fcr31 & C1_FLAG_INEXACT_OP),
		(bool)(fcr31 & C1_FLAG_UNDERFLOW),
		(bool)(fcr31 & C1_FLAG_OVERFLOW),
		(bool)(fcr31 & C1_FLAG_DIV_BY_0),
		(bool)(fcr31 & C1_FLAG_INVALID_OP)
	);

	fprintf(stdout, "--------------------------------------------------------------------------");

	fprintf(stdout, "z0:%08lX ",		(uint32_t)ex->regs->gpr[0]);
	fprintf(stdout, "at:%08lX ",		(uint32_t)ex->regs->gpr[1]);
	fprintf(stdout, "v0:%08lX ",		(uint32_t)ex->regs->gpr[2]);
	fprintf(stdout, "v1:%08lX ",		(uint32_t)ex->regs->gpr[3]);
	fprintf(stdout, "a0:%08lX ",		(uint32_t)ex->regs->gpr[4]);
	fprintf(stdout, "a1:%08lX\n",		(uint32_t)ex->regs->gpr[5]);
	fprintf(stdout, "a2:%08lX ",		(uint32_t)ex->regs->gpr[6]);
	fprintf(stdout, "a3:%08lX ",		(uint32_t)ex->regs->gpr[7]);
	fprintf(stdout, "t0:%08lX ",		(uint32_t)ex->regs->gpr[8]);
	fprintf(stdout, "t1:%08lX ",		(uint32_t)ex->regs->gpr[9]);
	fprintf(stdout, "t2:%08lX ",		(uint32_t)ex->regs->gpr[10]);
	fprintf(stdout, "t3:%08lX\n",		(uint32_t)ex->regs->gpr[11]);
	fprintf(stdout, "t4:%08lX ",		(uint32_t)ex->regs->gpr[12]);
	fprintf(stdout, "t5:%08lX ",		(uint32_t)ex->regs->gpr[13]);
	fprintf(stdout, "t6:%08lX ",		(uint32_t)ex->regs->gpr[14]);
	fprintf(stdout, "t7:%08lX ",		(uint32_t)ex->regs->gpr[15]);
	fprintf(stdout, "s0:%08lX ",		(uint32_t)ex->regs->gpr[16]);
	fprintf(stdout, "s1:%08lX\n",		(uint32_t)ex->regs->gpr[17]);
	fprintf(stdout, "s2:%08lX ",		(uint32_t)ex->regs->gpr[18]);
	fprintf(stdout, "s3:%08lX ",		(uint32_t)ex->regs->gpr[19]);
	fprintf(stdout, "s4:%08lX ",		(uint32_t)ex->regs->gpr[20]);
	fprintf(stdout, "s5:%08lX ",		(uint32_t)ex->regs->gpr[21]);
	fprintf(stdout, "s6:%08lX ",		(uint32_t)ex->regs->gpr[22]);
	fprintf(stdout, "s7:%08lX\n",		(uint32_t)ex->regs->gpr[23]);
	fprintf(stdout, "t8:%08lX ",		(uint32_t)ex->regs->gpr[24]);
	fprintf(stdout, "t9:%08lX ",		(uint32_t)ex->regs->gpr[25]);
	fprintf(stdout, "gp:%08lX ",		(uint32_t)ex->regs->gpr[28]);
	fprintf(stdout, "sp:%08lX ",		(uint32_t)ex->regs->gpr[29]);
	fprintf(stdout, "fp:%08lX ",		(uint32_t)ex->regs->gpr[30]);
	fprintf(stdout, "ra:%08lX\n",		(uint32_t)ex->regs->gpr[31]);
	fprintf(stdout, "lo:%08lX ",		(uint32_t)ex->regs->lo);
	fprintf(stdout, "hi:%08lX\n",		(uint32_t)ex->regs->hi);

	fprintf(stdout, "--------------------------------------------------------------------------");
	fprintf(stdout, "FP Registers:\n");
	for (int i = 0; i<32; i++) {
		fprintf(stdout, "%02u:%016llX ", i, ex->regs->fpr[i]);
		if ((i % 3) == 2) {
			fprintf(stdout, "\n");
		}
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "**************************************************************************");
}

/**
 * @brief Fetch the string name of the exception
 *
 * @param[in] cr
 *            Cause register's value
 *
 * @return String representation of the exception
 */
static const char* __get_exception_name(exception_code_t code)
{
	static const char* exceptionMap[] =
	{
		"Interrupt",								// 0
		"TLB Modification",							// 1
		"TLB Miss (load/instruction fetch)",		// 2
		"TLB Miss (store)",							// 3
		"Address Error (load/instruction fetch)",	// 4
		"Address Error (store)",					// 5
		"Bus Error (instruction fetch)",			// 6
		"Bus Error (data reference: load/store)",	// 7
		"Syscall",									// 8
		"Breakpoint",								// 9
		"Reserved Instruction",						// 10
		"Coprocessor Unusable",						// 11
		"Arithmetic Overflow",						// 12
		"Trap",										// 13
		"Reserved",									// 13
		"Floating-Point",							// 15
		"Reserved",									// 16
		"Reserved",									// 17
		"Reserved",									// 18
		"Reserved",									// 19
		"Reserved",									// 20
		"Reserved",									// 21
		"Reserved",									// 22
		"Watch",									// 23
		"Reserved",									// 24
		"Reserved",									// 25
		"Reserved",									// 26
		"Reserved",									// 27
		"Reserved",									// 28
		"Reserved",									// 29
		"Reserved",									// 30
		"Reserved",									// 31
	};

	return exceptionMap[code];
}

/**
 * @brief Fetch relevant registers
 *
 * @param[out] e
 *             Pointer to structure describing the exception
 * @param[in]  type
 *             Exception type.  Either #EXCEPTION_TYPE_CRITICAL or 
 *             #EXCEPTION_TYPE_RESET
 */
static void __fetch_regs(exception_t* e,int32_t type)
{
	e->regs = (volatile const reg_block_t*) &__baseRegAddr;
	e->type = type;
	e->code = C0_GET_CAUSE_EXC_CODE(e->regs->cr);
	e->info = __get_exception_name(e->code);
}

/**
 * @brief Respond to a critical exception
 */
void __onCriticalException()
{
	exception_t e;

	if(!__exception_handler) { return; }

	__fetch_regs(&e,EXCEPTION_TYPE_CRITICAL);
	__exception_handler(&e);
}

/**
 * @brief Respond to a reset exception
 */
void __onResetException()
{
	exception_t e;
	
	if(!__exception_handler) { return; }

	__fetch_regs(&e,EXCEPTION_TYPE_RESET);
	__exception_handler(&e);
}

/** @} */
