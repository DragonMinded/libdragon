/**
 * @file exception.c
 * @brief Exception Handler
 * @ingroup exceptions
 */
#include "exception.h"
#include <string.h>

/**
 * @defgroup exceptions Exception Handler
 * @ingroup lowlevel
 * @brief Handle hardware-generated exceptions.
 *
 * The exception handler traps exceptions generated by hardware.  This could
 * be an invalid instruction or invalid memory access exception or it could
 * be a reset exception.  In both cases, a handler registered with 
 * #register_exception_handler will be passed information regarding the
 * exception type and relevant registers.
 *
 * @{
 */

/** @brief Exception handler currently registered with exception system */
static void (*__exception_handler)(exception_t*) = NULL;
/** @brief Base register offset as defined by the interrupt controller */
extern const void* __baseRegAddr;

/**
 * @brief Register an exception handler to handle exceptions
 *
 * @param[in] cb
 *            Callback function to call when exceptions happen
 */
void register_exception_handler( void (*cb)(exception_t*))
{
	__exception_handler = cb;
}

/**
 * @brief Fetch the string name of the exception
 *
 * @param[in] cr
 *            Cause register's value
 *
 * @return String representation of the exception
 */
static const char* __get_exception_name(uint32_t cr)
{
	static const char* exceptionMap[] =
	{
		"Interrupt",								// 0
		"TLB Modification",							// 1
		"TLB Miss (load/instruction fetch)",		// 2
		"TLB Miss (store)",							// 3
		"Address Error (load/instruction fetch)",	// 4
		"Address Error (store)",					// 5
		"Bus Error (instruction fetch)",			// 6
		"Bus Error (data reference: load/store)",	// 7
		"Syscall",									// 8
		"Breakpoint",								// 9
		"Reserved Instruction",						// 10
		"Coprocessor Unusable",						// 11
		"Arithmetic Overflow",						// 12
		"Trap",										// 13
		"Reserved",									// 13
		"Floating-Point",							// 15
		"Reserved",									// 16
		"Reserved",									// 17
		"Reserved",									// 18
		"Reserved",									// 19
		"Reserved",									// 20
		"Reserved",									// 21
		"Reserved",									// 22
		"Watch",									// 23
		"Reserved",									// 24
		"Reserved",									// 25
		"Reserved",									// 26
		"Reserved",									// 27
		"Reserved",									// 28
		"Reserved",									// 29
		"Reserved",									// 30
		"Reserved",									// 31
	};

	return exceptionMap[(cr >> 2) & 0x1F];
}

/**
 * @brief Fetch relevant registers
 *
 * @param[out] e
 *             Pointer to structure describing the exception
 * @param[in]  type
 *             Exception type.  Either #EXCEPTION_TYPE_CRITICAL or 
 *             #EXCEPTION_TYPE_RESET
 */
static void __fetch_regs(exception_t* e,int32_t type)
{
	e->regs = (volatile const reg_block_t*) &__baseRegAddr;
	e->type = type;
	e->info = __get_exception_name((uint32_t)e->regs->cr);
}

/**
 * @brief Respond to a critical exception
 */
void __onCriticalException()
{
	exception_t e;

	if(!__exception_handler) { return; }

	__fetch_regs(&e,EXCEPTION_TYPE_CRITICAL);
	__exception_handler(&e);
}

/**
 * @brief Respond to a reset exception
 */
void __onResetException()
{
	exception_t e;
	
	if(!__exception_handler) { return; }

	__fetch_regs(&e,EXCEPTION_TYPE_RESET);
	__exception_handler(&e);
}

/** @} */
