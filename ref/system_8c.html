<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: system.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo2.png"/></td>
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">system.c File Reference<div class="ingroups"><a class="el" href="group__system.html">newlib Interface Hooks</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>newlib Interface Hooks  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structfs__mapping__t" id="r_structfs__mapping__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#structfs__mapping__t">fs_mapping_t</a></td></tr>
<tr class="memdesc:structfs__mapping__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filesystem mapping structure.  <a href="system_8c.html#structfs__mapping__t">More...</a><br /></td></tr>
<tr class="separator:structfs__mapping__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6423a880df59733d2d9b509c7718d3a9" id="r_a6423a880df59733d2d9b509c7718d3a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a6423a880df59733d2d9b509c7718d3a9">STACK_SIZE</a>&#160;&#160;&#160;0x10000</td></tr>
<tr class="memdesc:a6423a880df59733d2d9b509c7718d3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack size.  <br /></td></tr>
<tr class="separator:a6423a880df59733d2d9b509c7718d3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7932a38248a4a2527c35dc39564cb" id="r_ab0c7932a38248a4a2527c35dc39564cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#ab0c7932a38248a4a2527c35dc39564cb">DEBUG_OUT</a>(x)&#160;&#160;&#160;((uint32_t *)0xA4400044)[0] = ((uint32_t)(x))</td></tr>
<tr class="memdesc:ab0c7932a38248a4a2527c35dc39564cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the MESS debug register.  <br /></td></tr>
<tr class="separator:ab0c7932a38248a4a2527c35dc39564cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70d0d931ae689cf13ed804323d6c2ff" id="r_ab70d0d931ae689cf13ed804323d6c2ff"><td class="memItemLeft" align="right" valign="top"><a id="ab70d0d931ae689cf13ed804323d6c2ff" name="ab70d0d931ae689cf13ed804323d6c2ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BITS</b>(v,  b,  e)&#160;&#160;&#160;((unsigned int)(v) &lt;&lt; (31-(e)) &gt;&gt; (31-(e)+(b)))</td></tr>
<tr class="memdesc:ab70d0d931ae689cf13ed804323d6c2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract bits from word. <br /></td></tr>
<tr class="separator:ab70d0d931ae689cf13ed804323d6c2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0521c5aa7398d42869e19f78050a2b0f" id="r_a0521c5aa7398d42869e19f78050a2b0f"><td class="memItemLeft" align="right" valign="top"><a id="a0521c5aa7398d42869e19f78050a2b0f" name="a0521c5aa7398d42869e19f78050a2b0f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLE_MAX_BUCKETS</b>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:a0521c5aa7398d42869e19f78050a2b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of buckets file handles are divided into. <br /></td></tr>
<tr class="separator:a0521c5aa7398d42869e19f78050a2b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7791254fd88f7c9ad55f8bfd96892531" id="r_a7791254fd88f7c9ad55f8bfd96892531"><td class="memItemLeft" align="right" valign="top"><a id="a7791254fd88f7c9ad55f8bfd96892531" name="a7791254fd88f7c9ad55f8bfd96892531"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HANDLE_BUCKET_SIZE</b>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:a7791254fd88f7c9ad55f8bfd96892531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of each bucket of file handles. <br /></td></tr>
<tr class="separator:a7791254fd88f7c9ad55f8bfd96892531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0fb58608fb52a6e98cb85945a7f84e" id="r_aca0fb58608fb52a6e98cb85945a7f84e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#aca0fb58608fb52a6e98cb85945a7f84e">FILENO_MAKE</a>(bkt_idx,  bkt_pos,  fs_index)&#160;&#160;&#160;( (bkt_pos) | ((bkt_idx) &lt;&lt; 5) | (((fs_index)+1) &lt;&lt; 11) )</td></tr>
<tr class="memdesc:aca0fb58608fb52a6e98cb85945a7f84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fileno.  <br /></td></tr>
<tr class="separator:aca0fb58608fb52a6e98cb85945a7f84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762f8c798dbbeb2f5e95d028f30ebc0c" id="r_a762f8c798dbbeb2f5e95d028f30ebc0c"><td class="memItemLeft" align="right" valign="top"><a id="a762f8c798dbbeb2f5e95d028f30ebc0c" name="a762f8c798dbbeb2f5e95d028f30ebc0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FILENO_GET_FS_INDEX</b>(fileno)&#160;&#160;&#160;((int)<a class="el" href="rdpq__debug_8c.html#ab70d0d931ae689cf13ed804323d6c2ff">BITS</a>( (fileno), 11, 14 ) - 1)</td></tr>
<tr class="memdesc:a762f8c798dbbeb2f5e95d028f30ebc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the filesystem index from a fileno. <br /></td></tr>
<tr class="separator:a762f8c798dbbeb2f5e95d028f30ebc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa3b6dc9367fb33b11e0d6a6022619f" id="r_afaa3b6dc9367fb33b11e0d6a6022619f"><td class="memItemLeft" align="right" valign="top"><a id="afaa3b6dc9367fb33b11e0d6a6022619f" name="afaa3b6dc9367fb33b11e0d6a6022619f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FILENO_GET_BUCKET_IDX</b>(fileno)&#160;&#160;&#160;<a class="el" href="rdpq__debug_8c.html#ab70d0d931ae689cf13ed804323d6c2ff">BITS</a>( (fileno),  5, 10 )</td></tr>
<tr class="memdesc:afaa3b6dc9367fb33b11e0d6a6022619f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the bucket index from a fileno. <br /></td></tr>
<tr class="separator:afaa3b6dc9367fb33b11e0d6a6022619f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e0602f5794e66b5b66675da9ee826b" id="r_ab1e0602f5794e66b5b66675da9ee826b"><td class="memItemLeft" align="right" valign="top"><a id="ab1e0602f5794e66b5b66675da9ee826b" name="ab1e0602f5794e66b5b66675da9ee826b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FILENO_GET_BUCKET_POS</b>(fileno)&#160;&#160;&#160;<a class="el" href="rdpq__debug_8c.html#ab70d0d931ae689cf13ed804323d6c2ff">BITS</a>( (fileno),  0,  4 )</td></tr>
<tr class="memdesc:ab1e0602f5794e66b5b66675da9ee826b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the bucket position from a fileno. <br /></td></tr>
<tr class="separator:ab1e0602f5794e66b5b66675da9ee826b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">STDIN/STDOUT/STDERR definitions from unistd.h</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>We can't just include unistd.h as it redefines several of the functions here that we are attempting to replace. </p>
</div></td></tr>
<tr class="memitem:afcf80a6d91178952d107ad00b165752b" id="r_afcf80a6d91178952d107ad00b165752b"><td class="memItemLeft" align="right" valign="top"><a id="afcf80a6d91178952d107ad00b165752b" name="afcf80a6d91178952d107ad00b165752b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STDIN_FILENO</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:afcf80a6d91178952d107ad00b165752b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard input file descriptor. <br /></td></tr>
<tr class="separator:afcf80a6d91178952d107ad00b165752b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd165ee6474b5b75bf075842fff13a04" id="r_abd165ee6474b5b75bf075842fff13a04"><td class="memItemLeft" align="right" valign="top"><a id="abd165ee6474b5b75bf075842fff13a04" name="abd165ee6474b5b75bf075842fff13a04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STDOUT_FILENO</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:abd165ee6474b5b75bf075842fff13a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard output file descriptor. <br /></td></tr>
<tr class="separator:abd165ee6474b5b75bf075842fff13a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fe1725bb5e9823d089c46b9ed5266e" id="r_ae2fe1725bb5e9823d089c46b9ed5266e"><td class="memItemLeft" align="right" valign="top"><a id="ae2fe1725bb5e9823d089c46b9ed5266e" name="ae2fe1725bb5e9823d089c46b9ed5266e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STDERR_FILENO</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ae2fe1725bb5e9823d089c46b9ed5266e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard error file descriptor. <br /></td></tr>
<tr class="separator:ae2fe1725bb5e9823d089c46b9ed5266e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8877deace0c63591fee0cc9c94d249d3" id="r_a8877deace0c63591fee0cc9c94d249d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a8877deace0c63591fee0cc9c94d249d3">close</a> (int fileno)</td></tr>
<tr class="memdesc:a8877deace0c63591fee0cc9c94d249d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a file.  <br /></td></tr>
<tr class="separator:a8877deace0c63591fee0cc9c94d249d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacca6d970a0153055aa8c962067cdfdf1" id="r_gacca6d970a0153055aa8c962067cdfdf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__system.html#gacca6d970a0153055aa8c962067cdfdf1">attach_filesystem</a> (const char *const prefix, <a class="el" href="structfilesystem__t.html">filesystem_t</a> *filesystem)</td></tr>
<tr class="memdesc:gacca6d970a0153055aa8c962067cdfdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a filesystem with newlib.  <br /></td></tr>
<tr class="separator:gacca6d970a0153055aa8c962067cdfdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87492c7a75157f1aa852aedaf78e4d59" id="r_ga87492c7a75157f1aa852aedaf78e4d59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__system.html#ga87492c7a75157f1aa852aedaf78e4d59">detach_filesystem</a> (const char *const prefix)</td></tr>
<tr class="memdesc:ga87492c7a75157f1aa852aedaf78e4d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a filesystem from newlib.  <br /></td></tr>
<tr class="separator:ga87492c7a75157f1aa852aedaf78e4d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b89c77687f2ddc931aff3982814c39f" id="r_a1b89c77687f2ddc931aff3982814c39f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a1b89c77687f2ddc931aff3982814c39f">chown</a> (const char *path, uid_t owner, gid_t group)</td></tr>
<tr class="memdesc:a1b89c77687f2ddc931aff3982814c39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change ownership on a file or directory.  <br /></td></tr>
<tr class="separator:a1b89c77687f2ddc931aff3982814c39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1a7676150de79a9e494a9f7d926ae0" id="r_aff1a7676150de79a9e494a9f7d926ae0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#aff1a7676150de79a9e494a9f7d926ae0">execve</a> (char *name, char **argv, char **env)</td></tr>
<tr class="memdesc:aff1a7676150de79a9e494a9f7d926ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and execute an executable given a path.  <br /></td></tr>
<tr class="separator:aff1a7676150de79a9e494a9f7d926ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f3a2a875b4e08083b83d032adddc4d" id="r_a92f3a2a875b4e08083b83d032adddc4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a92f3a2a875b4e08083b83d032adddc4d">_exit</a> (int rc)</td></tr>
<tr class="memdesc:a92f3a2a875b4e08083b83d032adddc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">End execution on current thread.  <br /></td></tr>
<tr class="separator:a92f3a2a875b4e08083b83d032adddc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2e1ded4bb6fce4500438bf928330f4" id="r_acd2e1ded4bb6fce4500438bf928330f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#acd2e1ded4bb6fce4500438bf928330f4">fork</a> (void)</td></tr>
<tr class="memdesc:acd2e1ded4bb6fce4500438bf928330f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fork execution into two threads.  <br /></td></tr>
<tr class="separator:acd2e1ded4bb6fce4500438bf928330f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6104ed890cf8de16ee29498f40265c9f" id="r_a6104ed890cf8de16ee29498f40265c9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a6104ed890cf8de16ee29498f40265c9f">fstat</a> (int fileno, struct <a class="el" href="system_8c.html#a6267ee98ea4ca67296665534d549132a">stat</a> *st)</td></tr>
<tr class="memdesc:a6104ed890cf8de16ee29498f40265c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return stats on an open file handle.  <br /></td></tr>
<tr class="separator:a6104ed890cf8de16ee29498f40265c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939cb25a305fe68aad9b365077f1a8c7" id="r_a939cb25a305fe68aad9b365077f1a8c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a939cb25a305fe68aad9b365077f1a8c7">getpid</a> (void)</td></tr>
<tr class="memdesc:a939cb25a305fe68aad9b365077f1a8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the PID of the current thread.  <br /></td></tr>
<tr class="separator:a939cb25a305fe68aad9b365077f1a8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a876edb0b19bdb02035a8bab4919ed" id="r_a77a876edb0b19bdb02035a8bab4919ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a77a876edb0b19bdb02035a8bab4919ed">gettimeofday</a> (struct timeval *ptimeval, void *ptimezone)</td></tr>
<tr class="memdesc:a77a876edb0b19bdb02035a8bab4919ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current time.  <br /></td></tr>
<tr class="separator:a77a876edb0b19bdb02035a8bab4919ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf4c4b087df7b15fb2aa7401ddfc010" id="r_a2cf4c4b087df7b15fb2aa7401ddfc010"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a2cf4c4b087df7b15fb2aa7401ddfc010">isatty</a> (int file)</td></tr>
<tr class="memdesc:a2cf4c4b087df7b15fb2aa7401ddfc010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether a file is a TTY or a regular file.  <br /></td></tr>
<tr class="separator:a2cf4c4b087df7b15fb2aa7401ddfc010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17629c5f27ae250d924b74b1789e3b27" id="r_a17629c5f27ae250d924b74b1789e3b27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a17629c5f27ae250d924b74b1789e3b27">kill</a> (int pid, int sig)</td></tr>
<tr class="memdesc:a17629c5f27ae250d924b74b1789e3b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to a PID.  <br /></td></tr>
<tr class="separator:a17629c5f27ae250d924b74b1789e3b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3e19f457ca9695fad0aa3739ec9cdd" id="r_afe3e19f457ca9695fad0aa3739ec9cdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#afe3e19f457ca9695fad0aa3739ec9cdd">link</a> (char *existing, char *new)</td></tr>
<tr class="memdesc:afe3e19f457ca9695fad0aa3739ec9cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link a new file to an existing file.  <br /></td></tr>
<tr class="separator:afe3e19f457ca9695fad0aa3739ec9cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100b00771a8b06bfc443efb32da0f9d9" id="r_a100b00771a8b06bfc443efb32da0f9d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a100b00771a8b06bfc443efb32da0f9d9">lseek</a> (int file, int ptr, int dir)</td></tr>
<tr class="memdesc:a100b00771a8b06bfc443efb32da0f9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to a location in a file.  <br /></td></tr>
<tr class="separator:a100b00771a8b06bfc443efb32da0f9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94873fa89201b877351b663b9f5b040d" id="r_a94873fa89201b877351b663b9f5b040d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a94873fa89201b877351b663b9f5b040d">open</a> (const char *file, int flags,...)</td></tr>
<tr class="memdesc:a94873fa89201b877351b663b9f5b040d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file given a path.  <br /></td></tr>
<tr class="separator:a94873fa89201b877351b663b9f5b040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b746547993d7baf3b092ae620bfa666" id="r_a0b746547993d7baf3b092ae620bfa666"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a0b746547993d7baf3b092ae620bfa666">read</a> (int fileno, char *ptr, int len)</td></tr>
<tr class="memdesc:a0b746547993d7baf3b092ae620bfa666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file.  <br /></td></tr>
<tr class="separator:a0b746547993d7baf3b092ae620bfa666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6da607ddfd489b206b2707ee9ffe014" id="r_ae6da607ddfd489b206b2707ee9ffe014"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#ae6da607ddfd489b206b2707ee9ffe014">readlink</a> (const char *path, char *buf, size_t bufsize)</td></tr>
<tr class="memdesc:ae6da607ddfd489b206b2707ee9ffe014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a link.  <br /></td></tr>
<tr class="separator:ae6da607ddfd489b206b2707ee9ffe014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7c04d6d0cc62dd9f542e89c9d358fa" id="r_acc7c04d6d0cc62dd9f542e89c9d358fa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#acc7c04d6d0cc62dd9f542e89c9d358fa">sbrk</a> (int incr)</td></tr>
<tr class="memdesc:acc7c04d6d0cc62dd9f542e89c9d358fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new chunk of memory to be used as heap.  <br /></td></tr>
<tr class="separator:acc7c04d6d0cc62dd9f542e89c9d358fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6267ee98ea4ca67296665534d549132a" id="r_a6267ee98ea4ca67296665534d549132a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a6267ee98ea4ca67296665534d549132a">stat</a> (const char *file, struct stat *st)</td></tr>
<tr class="memdesc:a6267ee98ea4ca67296665534d549132a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return file stats based on a file name.  <br /></td></tr>
<tr class="separator:a6267ee98ea4ca67296665534d549132a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583cc849da2f23c2a3f6153f196b8a25" id="r_a583cc849da2f23c2a3f6153f196b8a25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a583cc849da2f23c2a3f6153f196b8a25">symlink</a> (const char *path1, const char *path2)</td></tr>
<tr class="memdesc:a583cc849da2f23c2a3f6153f196b8a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbolic link to a file.  <br /></td></tr>
<tr class="separator:a583cc849da2f23c2a3f6153f196b8a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fc89d71a97e11d44bdd0bbb851a9cb" id="r_a73fc89d71a97e11d44bdd0bbb851a9cb"><td class="memItemLeft" align="right" valign="top">clock_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a73fc89d71a97e11d44bdd0bbb851a9cb">times</a> (struct tms *buf)</td></tr>
<tr class="memdesc:a73fc89d71a97e11d44bdd0bbb851a9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return time information on the current process.  <br /></td></tr>
<tr class="separator:a73fc89d71a97e11d44bdd0bbb851a9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e154f3d23907c2f499b54d2d386fc9" id="r_ae6e154f3d23907c2f499b54d2d386fc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#ae6e154f3d23907c2f499b54d2d386fc9">unlink</a> (char *name)</td></tr>
<tr class="memdesc:ae6e154f3d23907c2f499b54d2d386fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a file based on filename.  <br /></td></tr>
<tr class="separator:ae6e154f3d23907c2f499b54d2d386fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6655447bab00753d59759423bf28e22e" id="r_a6655447bab00753d59759423bf28e22e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a6655447bab00753d59759423bf28e22e">wait</a> (int *status)</td></tr>
<tr class="memdesc:a6655447bab00753d59759423bf28e22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a child process.  <br /></td></tr>
<tr class="separator:a6655447bab00753d59759423bf28e22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8090da2a212e27317ea48ead1a19d6" id="r_aeb8090da2a212e27317ea48ead1a19d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#aeb8090da2a212e27317ea48ead1a19d6">write</a> (int file, char *ptr, int len)</td></tr>
<tr class="memdesc:aeb8090da2a212e27317ea48ead1a19d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a file.  <br /></td></tr>
<tr class="separator:aeb8090da2a212e27317ea48ead1a19d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af069d9aae45f54cadde63548780ca64a" id="r_af069d9aae45f54cadde63548780ca64a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#af069d9aae45f54cadde63548780ca64a">dir_findfirst</a> (const char *const path, <a class="el" href="group__system.html#structdir__t">dir_t</a> *dir)</td></tr>
<tr class="memdesc:af069d9aae45f54cadde63548780ca64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first file in a directory.  <br /></td></tr>
<tr class="separator:af069d9aae45f54cadde63548780ca64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f45aada2a3237bc3c59c8ceb3d88d20" id="r_a9f45aada2a3237bc3c59c8ceb3d88d20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a9f45aada2a3237bc3c59c8ceb3d88d20">dir_findnext</a> (const char *const path, <a class="el" href="group__system.html#structdir__t">dir_t</a> *dir)</td></tr>
<tr class="memdesc:a9f45aada2a3237bc3c59c8ceb3d88d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next file in a directory.  <br /></td></tr>
<tr class="separator:a9f45aada2a3237bc3c59c8ceb3d88d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a2591289aeb5ec5d9f73419533edc39" id="r_ga5a2591289aeb5ec5d9f73419533edc39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__system.html#ga5a2591289aeb5ec5d9f73419533edc39">hook_stdio_calls</a> (<a class="el" href="structstdio__t.html">stdio_t</a> *stdio_calls)</td></tr>
<tr class="memdesc:ga5a2591289aeb5ec5d9f73419533edc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook into stdio for STDIN, STDOUT and STDERR callbacks.  <br /></td></tr>
<tr class="separator:ga5a2591289aeb5ec5d9f73419533edc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ba22042b3c62d9213ac9121ce32b96f" id="r_ga6ba22042b3c62d9213ac9121ce32b96f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__system.html#ga6ba22042b3c62d9213ac9121ce32b96f">unhook_stdio_calls</a> (<a class="el" href="structstdio__t.html">stdio_t</a> *stdio_calls)</td></tr>
<tr class="memdesc:ga6ba22042b3c62d9213ac9121ce32b96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unhook from stdio.  <br /></td></tr>
<tr class="separator:ga6ba22042b3c62d9213ac9121ce32b96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ba40f92821927553a30e3c6e8c5214" id="r_ga52ba40f92821927553a30e3c6e8c5214"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__system.html#ga52ba40f92821927553a30e3c6e8c5214">hook_time_call</a> (time_t(*time_fn)(void))</td></tr>
<tr class="memdesc:ga52ba40f92821927553a30e3c6e8c5214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook into gettimeofday with a current time callback.  <br /></td></tr>
<tr class="separator:ga52ba40f92821927553a30e3c6e8c5214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3a0415a3cd3586014fdc4d1a793bf1" id="r_ga7c3a0415a3cd3586014fdc4d1a793bf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__system.html#ga7c3a0415a3cd3586014fdc4d1a793bf1">unhook_time_call</a> (time_t(*time_fn)(void))</td></tr>
<tr class="memdesc:ga7c3a0415a3cd3586014fdc4d1a793bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unhook from gettimeofday current time callback.  <br /></td></tr>
<tr class="separator:ga7c3a0415a3cd3586014fdc4d1a793bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f9b5b6613b1151a03915ee7b0ad21c" id="r_ad4f9b5b6613b1151a03915ee7b0ad21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#ad4f9b5b6613b1151a03915ee7b0ad21c">_flush_cache</a> (uint8_t *addr, unsigned long bytes)</td></tr>
<tr class="memdesc:ad4f9b5b6613b1151a03915ee7b0ad21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement _flush_cache as required by GCC for nested functions.  <br /></td></tr>
<tr class="separator:ad4f9b5b6613b1151a03915ee7b0ad21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620a4f992f76741d22c71a8736391bf6" id="r_a620a4f992f76741d22c71a8736391bf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a620a4f992f76741d22c71a8736391bf6">__assert_func</a> (const char *file, int line, const char *func, const char *failedexpr)</td></tr>
<tr class="memdesc:a620a4f992f76741d22c71a8736391bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement underlying function for assert()  <br /></td></tr>
<tr class="separator:a620a4f992f76741d22c71a8736391bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5428d66981cb84e60b899495874618b2" id="r_a5428d66981cb84e60b899495874618b2"><td class="memItemLeft" align="right" valign="top"><a id="a5428d66981cb84e60b899495874618b2" name="a5428d66981cb84e60b899495874618b2"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>__env</b> [1] = { 0 }</td></tr>
<tr class="memdesc:a5428d66981cb84e60b899495874618b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Environment variables. <br /></td></tr>
<tr class="separator:a5428d66981cb84e60b899495874618b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e83120dfc32290b3dfff131819edf38" id="r_a6e83120dfc32290b3dfff131819edf38"><td class="memItemLeft" align="right" valign="top"><a id="a6e83120dfc32290b3dfff131819edf38" name="a6e83120dfc32290b3dfff131819edf38"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>__assert_func_ptr</b> )(const char *file, int line, const char *func, const char *failedexpr)=0</td></tr>
<tr class="memdesc:a6e83120dfc32290b3dfff131819edf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert function pointer (initialized at startup) <br /></td></tr>
<tr class="separator:a6e83120dfc32290b3dfff131819edf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bde5bc5b3121ab6d4d1293f29a2718b" id="r_a7bde5bc5b3121ab6d4d1293f29a2718b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="system_8c.html#a7bde5bc5b3121ab6d4d1293f29a2718b">__bootcic</a></td></tr>
<tr class="memdesc:a7bde5bc5b3121ab6d4d1293f29a2718b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot CIC.  <br /></td></tr>
<tr class="separator:a7bde5bc5b3121ab6d4d1293f29a2718b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1773a6ccf3d1931f4d0c34b0c4ef5d5d" id="r_a1773a6ccf3d1931f4d0c34b0c4ef5d5d"><td class="memItemLeft" align="right" valign="top"><a id="a1773a6ccf3d1931f4d0c34b0c4ef5d5d" name="a1773a6ccf3d1931f4d0c34b0c4ef5d5d"></a>
time_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>time_hook</b> )(void) = NULL</td></tr>
<tr class="memdesc:a1773a6ccf3d1931f4d0c34b0c4ef5d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to provide the current time. <br /></td></tr>
<tr class="separator:a1773a6ccf3d1931f4d0c34b0c4ef5d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>newlib Interface Hooks </p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structfs__mapping__t" id="structfs__mapping__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structfs__mapping__t">&#9670;&#160;</a></span>fs_mapping_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fs_mapping_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Filesystem mapping structure. </p>
<p>This is used to look up what filesystem to use when passed a generic path. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="abfd00866b2e96f01d819383aa3e7cb02" name="abfd00866b2e96f01d819383aa3e7cb02"></a>char *</td>
<td class="fieldname">
prefix</td>
<td class="fielddoc">
Filesystem prefix. <p>This controls what filesystem prefix should link to this filesystem (eg. 'rom:/' or 'cf:/') </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a97474076859ee78d8a726ee9ca7a6d82" name="a97474076859ee78d8a726ee9ca7a6d82"></a><a class="el" href="structfilesystem__t.html">filesystem_t</a> *</td>
<td class="fieldname">
fs</td>
<td class="fielddoc">
Filesystem callback pointers. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a6423a880df59733d2d9b509c7718d3a9" name="a6423a880df59733d2d9b509c7718d3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6423a880df59733d2d9b509c7718d3a9">&#9670;&#160;</a></span>STACK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STACK_SIZE&#160;&#160;&#160;0x10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack size. </p>
<p>This is the maximum stack size for the purpose of malloc. Any malloc call that tries to allocate data will not allocate within this range. However, there is no guarantee that user code won't blow the stack and cause heap corruption. Use this as loose protection at best. </p>

</div>
</div>
<a id="ab0c7932a38248a4a2527c35dc39564cb" name="ab0c7932a38248a4a2527c35dc39564cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c7932a38248a4a2527c35dc39564cb">&#9670;&#160;</a></span>DEBUG_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_OUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((uint32_t *)0xA4400044)[0] = ((uint32_t)(x))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to the MESS debug register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>32-bit value to write to the MESS debug register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca0fb58608fb52a6e98cb85945a7f84e" name="aca0fb58608fb52a6e98cb85945a7f84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0fb58608fb52a6e98cb85945a7f84e">&#9670;&#160;</a></span>FILENO_MAKE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FILENO_MAKE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bkt_idx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bkt_pos, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fs_index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;( (bkt_pos) | ((bkt_idx) &lt;&lt; 5) | (((fs_index)+1) &lt;&lt; 11) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a fileno. </p>
<p>Filenos are created as bitfields containing a few fields.</p>
<p>They contain the indices required to access the handle in handle_map: the bucket index and the position within the bucket where the handle is.</p>
<p>They also contain the filesystem index, so that we always know which filesystem use to operate on the handle. Notice that the index is stored 1-based instead of 0-based, so that the special filenos 1,2,3 (used for stdin, stdout and stderr by C standard libraries) will never conflict with a fileno made by FILENO_MAKE.</p>
<dl class="section note"><dt>Note</dt><dd>POSIX does not specify any specific limit for filenos returned by <a class="el" href="system_8c.html#a94873fa89201b877351b663b9f5b040d" title="Open a file given a path.">open()</a>, besides that they need to be non-negative integers. Newlib stores them into a 16-bit signed integer though, so we are actually limited to 15 bits for them. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8877deace0c63591fee0cc9c94d249d3" name="a8877deace0c63591fee0cc9c94d249d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8877deace0c63591fee0cc9c94d249d3">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fileno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileno</td><td>File handle of the file to close</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="a1b89c77687f2ddc931aff3982814c39f" name="a1b89c77687f2ddc931aff3982814c39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b89c77687f2ddc931aff3982814c39f">&#9670;&#160;</a></span>chown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int chown </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change ownership on a file or directory. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported in libdragon</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the file or directory to operate on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">owner</td><td>New owner of the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>New group of the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="aff1a7676150de79a9e494a9f7d926ae0" name="aff1a7676150de79a9e494a9f7d926ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1a7676150de79a9e494a9f7d926ae0">&#9670;&#160;</a></span>execve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int execve </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and execute an executable given a path. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported in libdragon</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Filename of the executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>Array of pointers to arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">env</td><td>Array of pointers to environment variables</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="a92f3a2a875b4e08083b83d032adddc4d" name="a92f3a2a875b4e08083b83d032adddc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f3a2a875b4e08083b83d032adddc4d">&#9670;&#160;</a></span>_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _exit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End execution on current thread. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not exit. If this is the last thread, the system will hang.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rc</td><td>Return value of the exiting program </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd2e1ded4bb6fce4500438bf928330f4" name="acd2e1ded4bb6fce4500438bf928330f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2e1ded4bb6fce4500438bf928330f4">&#9670;&#160;</a></span>fork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fork </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fork execution into two threads. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported in libdragon.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>PID of child process if parent, 0 if child, negative value on failure. </dd></dl>

</div>
</div>
<a id="a6104ed890cf8de16ee29498f40265c9f" name="a6104ed890cf8de16ee29498f40265c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6104ed890cf8de16ee29498f40265c9f">&#9670;&#160;</a></span>fstat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fstat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fileno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="system_8c.html#a6267ee98ea4ca67296665534d549132a">stat</a> *&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return stats on an open file handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileno</td><td>File handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">st</td><td>Pointer to stat struct to be filled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="a939cb25a305fe68aad9b365077f1a8c7" name="a939cb25a305fe68aad9b365077f1a8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939cb25a305fe68aad9b365077f1a8c7">&#9670;&#160;</a></span>getpid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getpid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the PID of the current thread. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported in libdragon.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The PID on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="a77a876edb0b19bdb02035a8bab4919ed" name="a77a876edb0b19bdb02035a8bab4919ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a876edb0b19bdb02035a8bab4919ed">&#9670;&#160;</a></span>gettimeofday()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gettimeofday </td>
          <td>(</td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>ptimeval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptimezone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ptimeval</td><td>Time structure to be filled with current time. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptimezone</td><td>Timezone information to be filled. (Not supported)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="a2cf4c4b087df7b15fb2aa7401ddfc010" name="a2cf4c4b087df7b15fb2aa7401ddfc010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf4c4b087df7b15fb2aa7401ddfc010">&#9670;&#160;</a></span>isatty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isatty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether a file is a TTY or a regular file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the file is a TTY, or 0 if not. </dd></dl>

</div>
</div>
<a id="a17629c5f27ae250d924b74b1789e3b27" name="a17629c5f27ae250d924b74b1789e3b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17629c5f27ae250d924b74b1789e3b27">&#9670;&#160;</a></span>kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a signal to a PID. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported in libdragon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>The PID of the process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>The signal to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="afe3e19f457ca9695fad0aa3739ec9cdd" name="afe3e19f457ca9695fad0aa3739ec9cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3e19f457ca9695fad0aa3739ec9cdd">&#9670;&#160;</a></span>link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>existing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link a new file to an existing file. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported in libdragon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">existing</td><td>The path of the existing file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new</td><td>The path of the new file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="a100b00771a8b06bfc443efb32da0f9d9" name="a100b00771a8b06bfc443efb32da0f9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100b00771a8b06bfc443efb32da0f9d9">&#9670;&#160;</a></span>lseek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lseek </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek to a location in a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The file handle of the file to seek </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The offset in bytes to seek to, given the direction in dir </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>The direction to seek. Use SEEK_SET to start from the beginning. Use SEEK_CUR to seek based on the current offset. Use SEEK_END to seek starting at the end of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new location of the file in bytes or -1 on error. </dd></dl>

</div>
</div>
<a id="a94873fa89201b877351b663b9f5b040d" name="a94873fa89201b877351b663b9f5b040d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94873fa89201b877351b663b9f5b040d">&#9670;&#160;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file given a path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name of the file to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags specifying open flags, such as binary, append. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>mode Mode of the file (currently ignored).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>File handle to refer to this file on success, or a negative value on error. </dd></dl>

</div>
</div>
<a id="a0b746547993d7baf3b092ae620bfa666" name="a0b746547993d7baf3b092ae620bfa666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b746547993d7baf3b092ae620bfa666">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fileno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileno</td><td>Fileno for this file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>Data pointer to read data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length in bytes of data to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual number of bytes read or a negative value on error. </dd></dl>

</div>
</div>
<a id="ae6da607ddfd489b206b2707ee9ffe014" name="ae6da607ddfd489b206b2707ee9ffe014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6da607ddfd489b206b2707ee9ffe014">&#9670;&#160;</a></span>readlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a link. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported in libdragon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path of the link </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Buffer to read the link into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="acc7c04d6d0cc62dd9f542e89c9d358fa" name="acc7c04d6d0cc62dd9f542e89c9d358fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7c04d6d0cc62dd9f542e89c9d358fa">&#9670;&#160;</a></span>sbrk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * sbrk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new chunk of memory to be used as heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">incr</td><td>The amount of memory needed in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the memory or ((void*)-1) on error allocating. </dd></dl>

</div>
</div>
<a id="a6267ee98ea4ca67296665534d549132a" name="a6267ee98ea4ca67296665534d549132a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6267ee98ea4ca67296665534d549132a">&#9670;&#160;</a></span>stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct stat *&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return file stats based on a file name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name of the file in question </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">st</td><td>Stat struct to populate with information from the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="a583cc849da2f23c2a3f6153f196b8a25" name="a583cc849da2f23c2a3f6153f196b8a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583cc849da2f23c2a3f6153f196b8a25">&#9670;&#160;</a></span>symlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int symlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a symbolic link to a file. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported in libdragon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path1</td><td>Path to symlink to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path2</td><td>Path to symlink from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="a73fc89d71a97e11d44bdd0bbb851a9cb" name="a73fc89d71a97e11d44bdd0bbb851a9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fc89d71a97e11d44bdd0bbb851a9cb">&#9670;&#160;</a></span>times()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clock_t times </td>
          <td>(</td>
          <td class="paramtype">struct tms *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return time information on the current process. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported in libdragon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to place timing information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timing information or a negative value on error. </dd></dl>

</div>
</div>
<a id="ae6e154f3d23907c2f499b54d2d386fc9" name="ae6e154f3d23907c2f499b54d2d386fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e154f3d23907c2f499b54d2d386fc9">&#9670;&#160;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unlink </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a file based on filename. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the file to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="a6655447bab00753d59759423bf28e22e" name="a6655447bab00753d59759423bf28e22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6655447bab00753d59759423bf28e22e">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wait </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a child process. </p>
<dl class="section note"><dt>Note</dt><dd>Not supported in libdragon.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>Status of the wait operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negative value on error. </dd></dl>

</div>
</div>
<a id="aeb8090da2a212e27317ea48ead1a19d6" name="aeb8090da2a212e27317ea48ead1a19d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8090da2a212e27317ea48ead1a19d6">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to buffer to write to file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of data in bytes to be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual number of bytes written, or a negative value on error. </dd></dl>

</div>
</div>
<a id="af069d9aae45f54cadde63548780ca64a" name="af069d9aae45f54cadde63548780ca64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af069d9aae45f54cadde63548780ca64a">&#9670;&#160;</a></span>dir_findfirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dir_findfirst </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system.html#structdir__t">dir_t</a> *&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first file in a directory. </p>
<p>This function should be called to start enumerating a directory or whenever a directory enumeration should be restarted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the directory structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dir</td><td>Directory entry structure to populate with first entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful lookup or a negative value on error. </dd></dl>

</div>
</div>
<a id="a9f45aada2a3237bc3c59c8ceb3d88d20" name="a9f45aada2a3237bc3c59c8ceb3d88d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f45aada2a3237bc3c59c8ceb3d88d20">&#9670;&#160;</a></span>dir_findnext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dir_findnext </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__system.html#structdir__t">dir_t</a> *&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the next file in a directory. </p>
<p>After finding the first file in a directory using <a class="el" href="system_8c.html#af069d9aae45f54cadde63548780ca64a" title="Find the first file in a directory.">dir_findfirst</a>, call this to retrieve the rest of the directory entries. Call this repeatedly until a negative error is returned signifying that there are no more directory entries in the directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the directory structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dir</td><td>Directory entry structure to populate with next entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful lookup or a negative value on error. </dd></dl>

</div>
</div>
<a id="ad4f9b5b6613b1151a03915ee7b0ad21c" name="ad4f9b5b6613b1151a03915ee7b0ad21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f9b5b6613b1151a03915ee7b0ad21c">&#9670;&#160;</a></span>_flush_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _flush_cache </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement _flush_cache as required by GCC for nested functions. </p>
<p>When using the nested function extensions of GCC, a call to _flush_cache is generated which must be supplied by the operating system or runtime to allow flushing the instruction cache for the generated trampoline. </p>

</div>
</div>
<a id="a620a4f992f76741d22c71a8736391bf6" name="a620a4f992f76741d22c71a8736391bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620a4f992f76741d22c71a8736391bf6">&#9670;&#160;</a></span>__assert_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __assert_func </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>failedexpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement underlying function for assert() </p>
<p>Implementation of the function called when an assert fails. By default, we just abort execution, but this will be overriden at startup with a function that prints the assertion on the screen and via the debug channel (if initialized). </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7bde5bc5b3121ab6d4d1293f29a2718b" name="a7bde5bc5b3121ab6d4d1293f29a2718b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bde5bc5b3121ab6d4d1293f29a2718b">&#9670;&#160;</a></span>__bootcic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int __bootcic</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boot CIC. </p>
<p>Defaults to 6102. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 13 2024 18:46:35 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
