<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: rspq.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo2.png"/></td>
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_7132cdae52f2e6cf943a3c5275a8334f.html">rspq</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">rspq.c File Reference<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__lowlevel.html">Low Level Hardware Interfaces</a> &raquo; <a class="el" href="group__rsp.html">RSP: vector coprocessor</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>RSP Command queue.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structrspq__overlay__header__t" id="r_structrspq__overlay__header__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#structrspq__overlay__header__t">rspq_overlay_header_t</a></td></tr>
<tr class="memdesc:structrspq__overlay__header__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">The header of the overlay in DMEM.  <a href="rspq_8c.html#structrspq__overlay__header__t">More...</a><br /></td></tr>
<tr class="separator:structrspq__overlay__header__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structrspq__ctx__t" id="r_structrspq__ctx__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#structrspq__ctx__t">rspq_ctx_t</a></td></tr>
<tr class="memdesc:structrspq__ctx__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSP queue building context.  <a href="rspq_8c.html#structrspq__ctx__t">More...</a><br /></td></tr>
<tr class="separator:structrspq__ctx__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2118152cb9d7dc0097b43804307fbbd1" id="r_a2118152cb9d7dc0097b43804307fbbd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a2118152cb9d7dc0097b43804307fbbd1">rspq_append1</a>(ptr,  cmd,  arg1)</td></tr>
<tr class="memdesc:a2118152cb9d7dc0097b43804307fbbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smaller version of rspq_write that writes to an arbitrary pointer.  <br /></td></tr>
<tr class="separator:a2118152cb9d7dc0097b43804307fbbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca48a73c1e4b41a7d3bfb6778c1e499" id="r_a6ca48a73c1e4b41a7d3bfb6778c1e499"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a6ca48a73c1e4b41a7d3bfb6778c1e499">rspq_append2</a>(ptr,  cmd,  arg1,  arg2)</td></tr>
<tr class="memdesc:a6ca48a73c1e4b41a7d3bfb6778c1e499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smaller version of rspq_write that writes to an arbitrary pointer.  <br /></td></tr>
<tr class="separator:a6ca48a73c1e4b41a7d3bfb6778c1e499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35774d218ae64fd92d7360b8b32af13c" id="r_a35774d218ae64fd92d7360b8b32af13c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a35774d218ae64fd92d7360b8b32af13c">rspq_append3</a>(ptr,  cmd,  arg1,  arg2,  arg3)</td></tr>
<tr class="memdesc:a35774d218ae64fd92d7360b8b32af13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smaller version of rspq_write that writes to an arbitrary pointer.  <br /></td></tr>
<tr class="separator:a35774d218ae64fd92d7360b8b32af13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adca6c06c528a3dd772a288229cea9df8" id="r_adca6c06c528a3dd772a288229cea9df8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#adca6c06c528a3dd772a288229cea9df8">DEFINE_RSP_UCODE</a> (rsp_queue,.crash_handler=rspq_crash_handler,.assert_handler=rspq_assert_handler)</td></tr>
<tr class="separator:adca6c06c528a3dd772a288229cea9df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee149426cb6d86a71812a27b618d59c9" id="r_aee149426cb6d86a71812a27b618d59c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#aee149426cb6d86a71812a27b618d59c9">rspq_init</a> (void)</td></tr>
<tr class="memdesc:aee149426cb6d86a71812a27b618d59c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the RSPQ library.  <br /></td></tr>
<tr class="separator:aee149426cb6d86a71812a27b618d59c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32f5f99467e9e5e7c7590e34a254d02" id="r_ad32f5f99467e9e5e7c7590e34a254d02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#ad32f5f99467e9e5e7c7590e34a254d02">rspq_close</a> (void)</td></tr>
<tr class="memdesc:ad32f5f99467e9e5e7c7590e34a254d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down the RSPQ library.  <br /></td></tr>
<tr class="separator:ad32f5f99467e9e5e7c7590e34a254d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f709a49410891134670ee3a55ff27b" id="r_a24f709a49410891134670ee3a55ff27b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a24f709a49410891134670ee3a55ff27b">rspq_overlay_get_state</a> (<a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *overlay_ucode)</td></tr>
<tr class="memdesc:a24f709a49410891134670ee3a55ff27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the overlay state (in RDRAM)  <br /></td></tr>
<tr class="separator:a24f709a49410891134670ee3a55ff27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d8f0c474f13dded0cf8bcc811ebc32" id="r_ad8d8f0c474f13dded0cf8bcc811ebc32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rspq__internal_8h.html#structrsp__queue__t">rsp_queue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#ad8d8f0c474f13dded0cf8bcc811ebc32">__rspq_get_state</a> (void)</td></tr>
<tr class="memdesc:ad8d8f0c474f13dded0cf8bcc811ebc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a copy of the current RSPQ state.  <br /></td></tr>
<tr class="separator:ad8d8f0c474f13dded0cf8bcc811ebc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072c51be5126cfe5f914aefc52de950a" id="r_a072c51be5126cfe5f914aefc52de950a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a072c51be5126cfe5f914aefc52de950a">rspq_overlay_register</a> (<a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *overlay_ucode)</td></tr>
<tr class="memdesc:a072c51be5126cfe5f914aefc52de950a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a rspq overlay into the RSP queue engine.  <br /></td></tr>
<tr class="separator:a072c51be5126cfe5f914aefc52de950a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bb76d8572e721cb4fdd322a6f6cb43" id="r_a79bb76d8572e721cb4fdd322a6f6cb43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a79bb76d8572e721cb4fdd322a6f6cb43">rspq_overlay_register_static</a> (<a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *overlay_ucode, uint32_t overlay_id)</td></tr>
<tr class="memdesc:a79bb76d8572e721cb4fdd322a6f6cb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an overlay into the RSP queue engine assigning a static ID to it.  <br /></td></tr>
<tr class="separator:a79bb76d8572e721cb4fdd322a6f6cb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9b877ae18c66a9258c1b5d04c06e20" id="r_a1e9b877ae18c66a9258c1b5d04c06e20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a1e9b877ae18c66a9258c1b5d04c06e20">rspq_overlay_unregister</a> (uint32_t overlay_id)</td></tr>
<tr class="memdesc:a1e9b877ae18c66a9258c1b5d04c06e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a ucode overlay from the RSP queue engine.  <br /></td></tr>
<tr class="separator:a1e9b877ae18c66a9258c1b5d04c06e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d24ce57cd1b2cdb69297c97dab0eb21" id="r_a6d24ce57cd1b2cdb69297c97dab0eb21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a6d24ce57cd1b2cdb69297c97dab0eb21">rspq_next_buffer</a> (void)</td></tr>
<tr class="memdesc:a6d24ce57cd1b2cdb69297c97dab0eb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to the next write buffer for the current RSP queue.  <br /></td></tr>
<tr class="separator:a6d24ce57cd1b2cdb69297c97dab0eb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115e1839ffd27c126ed6076e2b5de0b8" id="r_a115e1839ffd27c126ed6076e2b5de0b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a115e1839ffd27c126ed6076e2b5de0b8">rspq_flush</a> (void)</td></tr>
<tr class="memdesc:a115e1839ffd27c126ed6076e2b5de0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure that RSP starts executing up to the last written command.  <br /></td></tr>
<tr class="separator:a115e1839ffd27c126ed6076e2b5de0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae546104d15d469518ac5fba15521e965" id="r_ae546104d15d469518ac5fba15521e965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#ae546104d15d469518ac5fba15521e965">rspq_highpri_begin</a> (void)</td></tr>
<tr class="memdesc:ae546104d15d469518ac5fba15521e965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start building a high-priority queue.  <br /></td></tr>
<tr class="separator:ae546104d15d469518ac5fba15521e965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae495b6d8ec49169f05e523fe564f9f4b" id="r_ae495b6d8ec49169f05e523fe564f9f4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#ae495b6d8ec49169f05e523fe564f9f4b">rspq_highpri_end</a> (void)</td></tr>
<tr class="memdesc:ae495b6d8ec49169f05e523fe564f9f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish building the high-priority queue and close it.  <br /></td></tr>
<tr class="separator:ae495b6d8ec49169f05e523fe564f9f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577581d5bf9cfecaa6a1becf3da21d6c" id="r_a577581d5bf9cfecaa6a1becf3da21d6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a577581d5bf9cfecaa6a1becf3da21d6c">rspq_highpri_sync</a> (void)</td></tr>
<tr class="memdesc:a577581d5bf9cfecaa6a1becf3da21d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the RSP to finish processing all high-priority queues.  <br /></td></tr>
<tr class="separator:a577581d5bf9cfecaa6a1becf3da21d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f292fc1f7b261f84c55fc356f86acf" id="r_a41f292fc1f7b261f84c55fc356f86acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a41f292fc1f7b261f84c55fc356f86acf">rspq_block_begin</a> (void)</td></tr>
<tr class="memdesc:a41f292fc1f7b261f84c55fc356f86acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin creating a new block.  <br /></td></tr>
<tr class="separator:a41f292fc1f7b261f84c55fc356f86acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81339d69802148a09829d1c6d9a9f9f6" id="r_a81339d69802148a09829d1c6d9a9f9f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rspq__internal_8h.html#structrspq__block__t">rspq_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a81339d69802148a09829d1c6d9a9f9f6">rspq_block_end</a> (void)</td></tr>
<tr class="memdesc:a81339d69802148a09829d1c6d9a9f9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish creating a block.  <br /></td></tr>
<tr class="separator:a81339d69802148a09829d1c6d9a9f9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d3fe8768ca839b49421bf08ac5b5c2" id="r_aa1d3fe8768ca839b49421bf08ac5b5c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#aa1d3fe8768ca839b49421bf08ac5b5c2">rspq_block_free</a> (<a class="el" href="rspq__internal_8h.html#structrspq__block__t">rspq_block_t</a> *block)</td></tr>
<tr class="memdesc:aa1d3fe8768ca839b49421bf08ac5b5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a block that is not needed any more.  <br /></td></tr>
<tr class="separator:aa1d3fe8768ca839b49421bf08ac5b5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad078c001303a1b2153ba99f3184194f3" id="r_ad078c001303a1b2153ba99f3184194f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#ad078c001303a1b2153ba99f3184194f3">rspq_block_run</a> (<a class="el" href="rspq__internal_8h.html#structrspq__block__t">rspq_block_t</a> *block)</td></tr>
<tr class="memdesc:ad078c001303a1b2153ba99f3184194f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to the RSP queue a command that runs a block.  <br /></td></tr>
<tr class="separator:ad078c001303a1b2153ba99f3184194f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92634614a959537f611d805b227defb7" id="r_a92634614a959537f611d805b227defb7"><td class="memItemLeft" align="right" valign="top"><a id="a92634614a959537f611d805b227defb7" name="a92634614a959537f611d805b227defb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rspq_block_run_rsp</b> (int nesting_level)</td></tr>
<tr class="memdesc:a92634614a959537f611d805b227defb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify that a RSP command is going to run a block. <br /></td></tr>
<tr class="separator:a92634614a959537f611d805b227defb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa2fb070de8f3af2ee1a454a4db2bf4" id="r_a5fa2fb070de8f3af2ee1a454a4db2bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a5fa2fb070de8f3af2ee1a454a4db2bf4">rspq_noop</a> ()</td></tr>
<tr class="memdesc:a5fa2fb070de8f3af2ee1a454a4db2bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a no-op command in the queue.  <br /></td></tr>
<tr class="separator:a5fa2fb070de8f3af2ee1a454a4db2bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6fb26b5312a98ad83f758cd7514e6e" id="r_a4d6fb26b5312a98ad83f758cd7514e6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a4d6fb26b5312a98ad83f758cd7514e6e">rspq_syncpoint_new</a> (void)</td></tr>
<tr class="memdesc:a4d6fb26b5312a98ad83f758cd7514e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a syncpoint in the queue.  <br /></td></tr>
<tr class="separator:a4d6fb26b5312a98ad83f758cd7514e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e818e81e25912cddbb86672dcd9976" id="r_a86e818e81e25912cddbb86672dcd9976"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a86e818e81e25912cddbb86672dcd9976">rspq_syncpoint_check</a> (<a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a> sync_id)</td></tr>
<tr class="memdesc:a86e818e81e25912cddbb86672dcd9976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a syncpoint was reached by RSP or not.  <br /></td></tr>
<tr class="separator:a86e818e81e25912cddbb86672dcd9976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aa6ceb175fd56a5969fa01985e1d60" id="r_ac3aa6ceb175fd56a5969fa01985e1d60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#ac3aa6ceb175fd56a5969fa01985e1d60">rspq_syncpoint_wait</a> (<a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a> sync_id)</td></tr>
<tr class="memdesc:ac3aa6ceb175fd56a5969fa01985e1d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until a syncpoint is reached by RSP.  <br /></td></tr>
<tr class="separator:ac3aa6ceb175fd56a5969fa01985e1d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3055d289f73a125e15b72429cfc91ed" id="r_af3055d289f73a125e15b72429cfc91ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#af3055d289f73a125e15b72429cfc91ed">rspq_wait</a> (void)</td></tr>
<tr class="memdesc:af3055d289f73a125e15b72429cfc91ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all commands in the queue have been executed by RSP.  <br /></td></tr>
<tr class="separator:af3055d289f73a125e15b72429cfc91ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af668e280d3621412dc28cbd59cf31ece" id="r_af668e280d3621412dc28cbd59cf31ece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#af668e280d3621412dc28cbd59cf31ece">rspq_dma_to_rdram</a> (void *rdram_addr, uint32_t dmem_addr, uint32_t len, bool is_async)</td></tr>
<tr class="memdesc:af668e280d3621412dc28cbd59cf31ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a command to do a DMA transfer from DMEM to RDRAM.  <br /></td></tr>
<tr class="separator:af668e280d3621412dc28cbd59cf31ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49e7a85fa93aff13b9818615b5db977" id="r_ac49e7a85fa93aff13b9818615b5db977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#ac49e7a85fa93aff13b9818615b5db977">rspq_dma_to_dmem</a> (uint32_t dmem_addr, void *rdram_addr, uint32_t len, bool is_async)</td></tr>
<tr class="memdesc:ac49e7a85fa93aff13b9818615b5db977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a command to do a DMA transfer from RDRAM to DMEM.  <br /></td></tr>
<tr class="separator:ac49e7a85fa93aff13b9818615b5db977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7853bba8cbf5773669b9e9ebd7f474cc" id="r_a7853bba8cbf5773669b9e9ebd7f474cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a7853bba8cbf5773669b9e9ebd7f474cc">rspq_write_begin</a> (uint32_t ovl_id, uint32_t cmd_id, int size)</td></tr>
<tr class="memdesc:a7853bba8cbf5773669b9e9ebd7f474cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin writing a new command into the RSP queue.  <br /></td></tr>
<tr class="separator:a7853bba8cbf5773669b9e9ebd7f474cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44674d8d8266f4a515b3fd4c6365b0b" id="r_ab44674d8d8266f4a515b3fd4c6365b0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#ab44674d8d8266f4a515b3fd4c6365b0b">rspq_write_arg</a> (<a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a> *w, uint32_t value)</td></tr>
<tr class="memdesc:ab44674d8d8266f4a515b3fd4c6365b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add one argument to the command being enqueued.  <br /></td></tr>
<tr class="separator:ab44674d8d8266f4a515b3fd4c6365b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f96b9087b04fe6a5f224728ff47701" id="r_a08f96b9087b04fe6a5f224728ff47701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rspq_8c.html#a08f96b9087b04fe6a5f224728ff47701">rspq_write_end</a> (<a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a> *w)</td></tr>
<tr class="memdesc:a08f96b9087b04fe6a5f224728ff47701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish enqueuing a command into the queue.  <br /></td></tr>
<tr class="separator:a08f96b9087b04fe6a5f224728ff47701"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a429a2ce7e73db61f7fb00a1b29f026f9" id="r_a429a2ce7e73db61f7fb00a1b29f026f9"><td class="memItemLeft" align="right" valign="top"><a id="a429a2ce7e73db61f7fb00a1b29f026f9" name="a429a2ce7e73db61f7fb00a1b29f026f9"></a>
<a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>rspq_overlay_ucodes</b> [RSPQ_MAX_OVERLAY_COUNT]</td></tr>
<tr class="memdesc:a429a2ce7e73db61f7fb00a1b29f026f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">RSPQ overlays. <br /></td></tr>
<tr class="separator:a429a2ce7e73db61f7fb00a1b29f026f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9098c8f501bd434c39772d66c33b28" id="r_a7e9098c8f501bd434c39772d66c33b28"><td class="memItemLeft" align="right" valign="top"><a id="a7e9098c8f501bd434c39772d66c33b28" name="a7e9098c8f501bd434c39772d66c33b28"></a>
<a class="el" href="rspq_8c.html#structrspq__ctx__t">rspq_ctx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>rspq_ctx</b></td></tr>
<tr class="memdesc:a7e9098c8f501bd434c39772d66c33b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current context. <br /></td></tr>
<tr class="separator:a7e9098c8f501bd434c39772d66c33b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721480d7b2d18bf1ad5b0d92c4b7e24b" id="r_a721480d7b2d18bf1ad5b0d92c4b7e24b"><td class="memItemLeft" align="right" valign="top"><a id="a721480d7b2d18bf1ad5b0d92c4b7e24b" name="a721480d7b2d18bf1ad5b0d92c4b7e24b"></a>
volatile uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>rspq_cur_pointer</b></td></tr>
<tr class="memdesc:a721480d7b2d18bf1ad5b0d92c4b7e24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy of the current write pointer (see <a class="el" href="rspq_8c.html#structrspq__ctx__t" title="RSP queue building context.">rspq_ctx_t</a>) <br /></td></tr>
<tr class="separator:a721480d7b2d18bf1ad5b0d92c4b7e24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ef4eabdbb9a204474c2b7fe58975e8" id="r_af6ef4eabdbb9a204474c2b7fe58975e8"><td class="memItemLeft" align="right" valign="top"><a id="af6ef4eabdbb9a204474c2b7fe58975e8" name="af6ef4eabdbb9a204474c2b7fe58975e8"></a>
volatile uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><b>rspq_cur_sentinel</b></td></tr>
<tr class="memdesc:af6ef4eabdbb9a204474c2b7fe58975e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy of the current write sentinel (see <a class="el" href="rspq_8c.html#structrspq__ctx__t" title="RSP queue building context.">rspq_ctx_t</a>) <br /></td></tr>
<tr class="separator:af6ef4eabdbb9a204474c2b7fe58975e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4176e918c2df86254ed85965373c0945" id="r_a4176e918c2df86254ed85965373c0945"><td class="memItemLeft" align="right" valign="top"><a id="a4176e918c2df86254ed85965373c0945" name="a4176e918c2df86254ed85965373c0945"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>rspq_rdp_dynamic_buffers</b> [2]</td></tr>
<tr class="memdesc:a4176e918c2df86254ed85965373c0945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers that hold outgoing RDP commands (generated via RSP). <br /></td></tr>
<tr class="separator:a4176e918c2df86254ed85965373c0945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b062e3a4bdd3e3873623ae630fc9f4" id="r_a39b062e3a4bdd3e3873623ae630fc9f4"><td class="memItemLeft" align="right" valign="top"><a id="a39b062e3a4bdd3e3873623ae630fc9f4" name="a39b062e3a4bdd3e3873623ae630fc9f4"></a>
<a class="el" href="rspq__internal_8h.html#structrspq__block__t">rspq_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>rspq_block</b></td></tr>
<tr class="memdesc:a39b062e3a4bdd3e3873623ae630fc9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the current block being built, or NULL. <br /></td></tr>
<tr class="separator:a39b062e3a4bdd3e3873623ae630fc9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb2ee1cdad42a176be51abf5530bc0f" id="r_a4bb2ee1cdad42a176be51abf5530bc0f"><td class="memItemLeft" align="right" valign="top"><a id="a4bb2ee1cdad42a176be51abf5530bc0f" name="a4bb2ee1cdad42a176be51abf5530bc0f"></a>
volatile int&#160;</td><td class="memItemRight" valign="bottom"><b>__rspq_syncpoints_done</b></td></tr>
<tr class="memdesc:a4bb2ee1cdad42a176be51abf5530bc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID of the last syncpoint reached by RSP. <br /></td></tr>
<tr class="separator:a4bb2ee1cdad42a176be51abf5530bc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RSP Command queue. </p>
<h1><a class="anchor" id="autotoc_md26"></a>
RSP Queue: implementation</h1>
<p>This documentation block describes the internal workings of the RSP Queue. This is useful to understand the implementation. For description of the API of the RSP queue, see <a class="el" href="rspq_8h.html" title="RSP Command queue.">rspq.h</a></p>
<h2><a class="anchor" id="autotoc_md27"></a>
Architecture</h2>
<p>The RSP queue can be thought in abstract as a single contiguous memory buffer that contains RSP commands. The CPU is the writing part, which appends command to the buffer. The RSP is the reading part, which reads commands and execute them. Both work at the same time on the same buffer, so careful engineering is required to make sure that they do not interfere with each other.</p>
<p>The complexity of this library is trying to achieve this design without any explicit synchronization primitive. The basic design constraint is that, in the standard code path, the CPU should be able to just append a new command in the buffer without talking to the RSP, and the RSP should be able to just read a new command from the buffer without talking to the CPU. Obviously there are side cases where the synchronization is required (eg: if the RSP catches up with the CPU, or if the CPU fins that the buffer is full), but these cases should in general be rare.</p>
<p>To achieve a fully lockless approach, there are specific rules that the CPU has to follow while writing to make sure that the RSP does not get confused and execute invalid or partially-written commands. On the other hand, the RSP must be careful in discerning between a fully-written command and a partially-written command, and at the same time not waste memory bandwidth to continuously "poll" the buffer when it has caught up with the CPU.</p>
<p>The RSP uses the following algorithm to parse the buffer contents. Assume for now that the buffer is linear and unlimited in size.</p>
<ol type="1">
<li>The RSP fetches a "portion" of the buffer from RDRAM to DMEM. The size of the portion is RSPQ_DMEM_BUFFER_SIZE. It also resets its internal read pointer to the start of the DMEM buffer.</li>
<li>The RSP reads the first byte pointed by the internal read pointer. The first byte is the command ID. It splits it into overlay ID (4 bits) and command index (4 bits).</li>
<li>If the command is 0x00 (overlay 0, index 0), it means that the RSP has caught up with the CPU and there are no more pending commands.<ul>
<li>The RSP checks whether the signal SIG_MORE was set by the CPU. This signal is set any time the CPU writes a new command in the queue. If the signal is set, it means that the CPU has continued writing but the RSP has probably fetched the buffer before those commands were written. The RSP goes back to step 1 (refetch the buffer, from the current position).</li>
<li>If SIG_MORE is not set, the RSP has really caught up the CPU, and no more commands are available in the queue. The RSP goes to sleep via the BREAK opcode, and waits for the CPU to wake it up when more commands are available.</li>
<li>After the CPU has woken the RSP, it goes back to step 1.</li>
</ul>
</li>
<li>If the overlay ID refers to an overlay which is not the currently loaded one, the RSP loads the new overlay into IMEM/DMEM. Before doing so, it also saves the current overlay's state back into RDRAM (this is a portion of DMEM specified by the overlay itself as "state", that is preserved across overlay switching).</li>
<li>The RSP uses the command index to fetch the "command descriptor", a small structure that contains a pointer to the function in IMEM that executes the command, and the size of the command in word.</li>
<li>If the command overflows the internal buffer (that is, it is longer than the number of bytes left in the buffer), it means that we need to refetch a subsequent portion of the buffer to see the whole command. Go back to step 1.</li>
<li>The RSP jumps to the function that executes the command. After the command is finished, the function is expected to jump back to the main loop, going to step 2.</li>
</ol>
<p>Given the above algorithm, it is easy to understand how the CPU must behave when filling the buffer:</p>
<ul>
<li>The buffer must be initialized with 0x00. This makes sure that unwritten portions of the buffers are seen as "special command 0x00" by the RSP.</li>
<li>The CPU must take special care not to write the command ID before the full command is written. For instance let's say a command is made by two words: 0xAB000001 0xFFFF8000 (overlay 0xA, command index 0xB, length 2). If the CPU writes the two words in the standard order, there might be a race where the RSP reads the memory via DMA when only the first word has been written, and thus see 0xAB000001 0x00000000, executing the command with a wrong second word. So the CPU has to write the first word as last (or at least its first byte must be written last).</li>
<li>It is important that the C compiler does not reorder writes. In general, compilers are allowed to change the order in which writes are performed in a buffer. For instance, if the code writes to buf[0], buf[1], buf[2], the compiler might decide to generate code that writes buf[2] first, for optimization reasons. It is possible to fix it using the <a class="el" href="group__n64sys.html#ga56d4cbe1e093c683432a147eb1ccb293" title="Memory barrier to ensure in-order execution.">MEMORY_BARRIER</a> macro, or the volatile qualifier (which guarantees a fixed order of accesses between volatile pointers, though non-volatile accesses can be reordered freely also across volatile ones).</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
Internal commands</h2>
<p>To manage the queue and implement all the various features, rspq reserves for itself the overlay ID 0x0 to implement internal commands. You can look at the list of commands and their description below. All command IDs are defined with <code>RSPQ_CMD_*</code> macros.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Buffer swapping</h2>
<p>Internally, double buffering is used to implement the queue. The size of each of the buffers is RSPQ_DRAM_LOWPRI_BUFFER_SIZE. When a buffer is full, the queue engine writes a <a class="el" href="rspq__internal_8h.html#aba01db17f4a2bfbc3db60dc172972a25a58023050f9d78e7cf4dc6c6cee07b6e5" title="RSPQ command: Jump to another buffer.">RSPQ_CMD_JUMP</a> command with the address of the other buffer, to tell the RSP to jump there when it is done.</p>
<p>Moreover, just before the jump, the engine also enqueue a <a class="el" href="rspq__internal_8h.html#aba01db17f4a2bfbc3db60dc172972a25ae0ee81ba2ae47bd82a5cf662bab63ca5" title="RSPQ Command: write SP_STATUS register.">RSPQ_CMD_WRITE_STATUS</a> command that sets the SP_STATUS_SIG_BUFDONE_LOW signal. This is used to keep track when the RSP has finished processing a buffer, so that we know it becomes free again for more commands.</p>
<p>This logic is implemented in <a class="el" href="rspq_8c.html#a6d24ce57cd1b2cdb69297c97dab0eb21" title="Switch to the next write buffer for the current RSP queue.">rspq_next_buffer</a>.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Blocks</h2>
<p>Blocks are implemented by redirecting <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> to a different memory buffer, allocated for the block. The starting size for this buffer is RSPQ_BLOCK_MIN_SIZE. If the buffer becomes full, a new buffer is allocated with double the size (to achieve exponential growth), and it is linked to the previous buffer via a <a class="el" href="rspq__internal_8h.html#aba01db17f4a2bfbc3db60dc172972a25a58023050f9d78e7cf4dc6c6cee07b6e5" title="RSPQ command: Jump to another buffer.">RSPQ_CMD_JUMP</a>. So a block can end up being defined by multiple memory buffers linked via jumps.</p>
<p>Calling a block requires some work because of the nesting calls we want to support. To make the RSP ucode as short as possible, the two internal command dedicated to block calls (<a class="el" href="rspq__internal_8h.html#aba01db17f4a2bfbc3db60dc172972a25a3bcc1ebb86dbfab31f34d0153d3a9a14" title="RSPQ command: Call a block.">RSPQ_CMD_CALL</a> and <a class="el" href="rspq__internal_8h.html#aba01db17f4a2bfbc3db60dc172972a25ae3aa621c30e8ea451128c8ff98d14f44" title="RSPQ command: Return from a block.">RSPQ_CMD_RET</a>) do not manage a call stack by themselves, but only allow to save/restore the current queue position from a "save slot", whose index must be provided by the CPU.</p>
<p>Thus, the CPU has to make sure that each CALL opcode saves the position into a save slot which will not be overwritten by nested block calls. To do this, it calculates the "nesting level" of a block at block creation time: the nesting level of a block is defined by the smallest number greater than the nesting levels of all blocks that are called within the block itself. So for instance if a block calls another block whose nesting level is 5, it will get assigned a level of 6. The nesting level is then used as call slot in both all future calls to the block, and by the RSPQ_CMD_RET command placed at the end of the block itself.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Highpri queue</h2>
<p>The high priority queue is implemented as an alternative couple of buffers, that replace the standard buffers when the high priority mode is activated.</p>
<p>When <a class="el" href="rspq_8c.html#ae546104d15d469518ac5fba15521e965" title="Start building a high-priority queue.">rspq_highpri_begin</a> is called, the CPU notifies the RSP that it must switch to the highpri queues by setting signal SP_STATUS_SIG_HIGHPRI_REQUESTED. The RSP checks for that signal between each command, and when it sees it, it internally calls <a class="el" href="rspq__internal_8h.html#aba01db17f4a2bfbc3db60dc172972a25a8d8fd35254ac74cdb0b1abdb364fb64e" title="RSPQ Command: Swap lowpri/highpri buffers.">RSPQ_CMD_SWAP_BUFFERS</a>. This command loads the highpri queue pointer from a special call slot, saves the current lowpri queue position in another special save slot, and finally clear SP_STATUS_SIG_HIGHPRI_REQUESTED and set SP_STATUS_SIG_HIGHPRI_RUNNING instead.</p>
<p>When the <a class="el" href="rspq_8c.html#ae495b6d8ec49169f05e523fe564f9f4b" title="Finish building the high-priority queue and close it.">rspq_highpri_end</a> is called, the opposite is done. The CPU writes in the queue a <a class="el" href="rspq__internal_8h.html#aba01db17f4a2bfbc3db60dc172972a25a8d8fd35254ac74cdb0b1abdb364fb64e" title="RSPQ Command: Swap lowpri/highpri buffers.">RSPQ_CMD_SWAP_BUFFERS</a> that saves the current highpri pointer into its call slot, recover the previous lowpri position, and turns off SP_STATUS_SIG_HIGHPRI_RUNNING.</p>
<p>Some careful tricks are necessary to allow multiple highpri queues to be pending, see <a class="el" href="rspq_8c.html#ae546104d15d469518ac5fba15521e965" title="Start building a high-priority queue.">rspq_highpri_begin</a> for details.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
rdpq integrations</h2>
<p>There are a few places where the rsqp code is hooked with rdpq to provide for coherent usage of the two peripherals. In particular:</p>
<ul>
<li><a class="el" href="rspq_8c.html#af3055d289f73a125e15b72429cfc91ed" title="Wait until all commands in the queue have been executed by RSP.">rspq_wait</a> automatically calls <a class="el" href="rdpq_8c.html#aeb872b5dba9db3ba975bf2b3b8282e71" title="Public rdpq_fence API, redefined it.">rdpq_fence</a>. This means that it will also wait for RDP to finish executing all commands, which is actually expected for its intended usage of "full sync for debugging
   purposes".</li>
<li>All rsqp block creation functions call into hooks in rdpq. This is necessary because blocks are specially handled by rdpq via static buffer, to make sure RDP commands in the block don't passthrough via RSP, but are directly DMA from RDRAM into RDP. Moreover, See <a class="el" href="rdpq_8c.html" title="RDP Command queue.">rdpq.c</a> documentation for more details.</li>
<li>In specific places, we call into the rdpq debugging module to help tracing the RDP commands. For instance, when switching RDP RDRAM buffers, RSP will generate an interrupt to inform the debugging code that it needs to finish dumping the previous RDP buffer. </li>
</ul>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structrspq__overlay__header__t" id="structrspq__overlay__header__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrspq__overlay__header__t">&#9670;&#160;</a></span>rspq_overlay_header_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rspq_overlay_header_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The header of the overlay in DMEM. </p>
<p>This structure is placed at the start of the overlay in DMEM, via the RSPQ_OverlayHeader macros (defined in rsp_queue.inc). </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a27760ae81e110680026727e1ebe5ff3f" name="a27760ae81e110680026727e1ebe5ff3f"></a>uint16_t</td>
<td class="fieldname">
state_start</td>
<td class="fielddoc">
Start of the portion of DMEM used as "state". </td></tr>
<tr><td class="fieldtype">
<a id="a1394d95905ca1447f947968e550e9b39" name="a1394d95905ca1447f947968e550e9b39"></a>uint16_t</td>
<td class="fieldname">
state_size</td>
<td class="fielddoc">
Size of the portion of DMEM used as "state". </td></tr>
<tr><td class="fieldtype">
<a id="acb366b7207e3ac203f8282aa816b9536" name="acb366b7207e3ac203f8282aa816b9536"></a>uint16_t</td>
<td class="fieldname">
command_base</td>
<td class="fielddoc">
Primary overlay ID used for this overlay. </td></tr>
<tr><td class="fieldtype">
<a id="aa8765468f9551ae46367f675e6d726f4" name="aa8765468f9551ae46367f675e6d726f4"></a>uint16_t</td>
<td class="fieldname">
reserved</td>
<td class="fielddoc">
Unused. </td></tr>
<tr><td class="fieldtype">
<a id="af8d1b8d75f4a1f4f8ceaab2a91a2df22" name="af8d1b8d75f4a1f4f8ceaab2a91a2df22"></a>uint16_t</td>
<td class="fieldname">
commands[]</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structrspq__ctx__t" id="structrspq__ctx__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structrspq__ctx__t">&#9670;&#160;</a></span>rspq_ctx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rspq_ctx_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>RSP queue building context. </p>
<p>This structure contains the state of a RSP queue as it is built by the CPU. It is instantiated two times: one for the lwopri queue, and one for the highpri queue. It contains the two buffers used in the double buffering scheme, and some metadata about the queue.</p>
<p>The current write pointer is stored in the "cur" field. The "sentinel" field contains the pointer to the last byte at which a new command can start, before overflowing the buffer (given <a class="el" href="rspq_8h.html#a5c35e691b9651ffc302d590a47d47418" title="Maximum size of a command (in 32-bit words).">RSPQ_MAX_COMMAND_SIZE</a>). This is used for efficiently check when it is time to switch to the other buffer: basically, it is sufficient to check whether "cur &gt; sentinel".</p>
<p>The current queue is stored in 3 global pointers: <a class="el" href="rspq_8c.html#a7e9098c8f501bd434c39772d66c33b28" title="Current context.">rspq_ctx</a>, <a class="el" href="rspq_8c.html#a721480d7b2d18bf1ad5b0d92c4b7e24b" title="Copy of the current write pointer (see rspq_ctx_t)">rspq_cur_pointer</a> and <a class="el" href="rspq_8c.html#af6ef4eabdbb9a204474c2b7fe58975e8" title="Copy of the current write sentinel (see rspq_ctx_t)">rspq_cur_sentinel</a>. <a class="el" href="rspq_8c.html#a721480d7b2d18bf1ad5b0d92c4b7e24b" title="Copy of the current write pointer (see rspq_ctx_t)">rspq_cur_pointer</a> and <a class="el" href="rspq_8c.html#af6ef4eabdbb9a204474c2b7fe58975e8" title="Copy of the current write sentinel (see rspq_ctx_t)">rspq_cur_sentinel</a> are external copies of the "cur" and "sentinel" pointer of the current context, but they are kept as separate global variables for maximum performance of the hottest code path: <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>. In fact, it is much faster to access a global 32-bit pointer (via gp-relative offset) than dereferencing a member of a global structure pointer.</p>
<p>rspq_switch_context is called to switch between lowpri and highpri, updating the three global pointers.</p>
<p>When building a block, <a class="el" href="rspq_8c.html#a7e9098c8f501bd434c39772d66c33b28" title="Current context.">rspq_ctx</a> is set to NULL, while the other two pointers point inside the block memory. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a93f8aadcb6c6c2280ac68edd454788f3" name="a93f8aadcb6c6c2280ac68edd454788f3"></a>void *</td>
<td class="fieldname">
buffers[2]</td>
<td class="fielddoc">
The two buffers used to build the RSP queue. </td></tr>
<tr><td class="fieldtype">
<a id="aa3e96f7c2dc1e63950bce7a2fee89bc2" name="aa3e96f7c2dc1e63950bce7a2fee89bc2"></a>int</td>
<td class="fieldname">
buf_size</td>
<td class="fielddoc">
Size of each buffer in 32-bit words. </td></tr>
<tr><td class="fieldtype">
<a id="a2750af40f94d8f7fbb250e03565b4647" name="a2750af40f94d8f7fbb250e03565b4647"></a>int</td>
<td class="fieldname">
buf_idx</td>
<td class="fielddoc">
Index of the buffer currently being written to. </td></tr>
<tr><td class="fieldtype">
<a id="aadf8b9984e0c1f121f53d788a3977b9f" name="aadf8b9984e0c1f121f53d788a3977b9f"></a>uint32_t</td>
<td class="fieldname">
sp_status_bufdone</td>
<td class="fielddoc">
SP status bit to signal that one buffer has been run by RSP. </td></tr>
<tr><td class="fieldtype">
<a id="a8c25c97750d9657fa698eb610dc9d900" name="a8c25c97750d9657fa698eb610dc9d900"></a>uint32_t</td>
<td class="fieldname">
sp_wstatus_set_bufdone</td>
<td class="fielddoc">
SP mask to set the bufdone bit. </td></tr>
<tr><td class="fieldtype">
<a id="a98728d963c86881692d4458e26cbc55f" name="a98728d963c86881692d4458e26cbc55f"></a>uint32_t</td>
<td class="fieldname">
sp_wstatus_clear_bufdone</td>
<td class="fielddoc">
SP mask to clear the bufdone bit. </td></tr>
<tr><td class="fieldtype">
<a id="aceadf8d01ba0872e1e1cff5068c830d7" name="aceadf8d01ba0872e1e1cff5068c830d7"></a>volatile uint32_t *</td>
<td class="fieldname">
cur</td>
<td class="fielddoc">
Current write pointer within the active buffer. </td></tr>
<tr><td class="fieldtype">
<a id="aaa5f5b1d72225363c4b5c62ccce87c78" name="aaa5f5b1d72225363c4b5c62ccce87c78"></a>volatile uint32_t *</td>
<td class="fieldname">
sentinel</td>
<td class="fielddoc">
Current write sentinel within the active buffer. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2118152cb9d7dc0097b43804307fbbd1" name="a2118152cb9d7dc0097b43804307fbbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2118152cb9d7dc0097b43804307fbbd1">&#9670;&#160;</a></span>rspq_append1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rspq_append1</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmd, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg1&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    ((<span class="keyword">volatile</span> uint32_t*)(ptr))[0] = ((cmd)&lt;&lt;24) | (arg1); \</div>
<div class="line">    ptr += 1; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Smaller version of rspq_write that writes to an arbitrary pointer. </p>

</div>
</div>
<a id="a6ca48a73c1e4b41a7d3bfb6778c1e499" name="a6ca48a73c1e4b41a7d3bfb6778c1e499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca48a73c1e4b41a7d3bfb6778c1e499">&#9670;&#160;</a></span>rspq_append2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rspq_append2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmd, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    ((<span class="keyword">volatile</span> uint32_t*)(ptr))[1] = (arg2); \</div>
<div class="line">    ((<span class="keyword">volatile</span> uint32_t*)(ptr))[0] = ((cmd)&lt;&lt;24) | (arg1); \</div>
<div class="line">    ptr += 2; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Smaller version of rspq_write that writes to an arbitrary pointer. </p>

</div>
</div>
<a id="a35774d218ae64fd92d7360b8b32af13c" name="a35774d218ae64fd92d7360b8b32af13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35774d218ae64fd92d7360b8b32af13c">&#9670;&#160;</a></span>rspq_append3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rspq_append3</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmd, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ \</div>
<div class="line">    ((<span class="keyword">volatile</span> uint32_t*)(ptr))[1] = (arg2); \</div>
<div class="line">    ((<span class="keyword">volatile</span> uint32_t*)(ptr))[2] = (arg3); \</div>
<div class="line">    ((<span class="keyword">volatile</span> uint32_t*)(ptr))[0] = ((cmd)&lt;&lt;24) | (arg1); \</div>
<div class="line">    ptr += 3; \</div>
<div class="line">})</div>
</div><!-- fragment -->
<p>Smaller version of rspq_write that writes to an arbitrary pointer. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adca6c06c528a3dd772a288229cea9df8" name="adca6c06c528a3dd772a288229cea9df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca6c06c528a3dd772a288229cea9df8">&#9670;&#160;</a></span>DEFINE_RSP_UCODE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DEFINE_RSP_UCODE </td>
          <td>(</td>
          <td class="paramtype">rsp_queue&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">.&#160;</td>
          <td class="paramname"><em>crash_handler</em> = <code>rspq_crash_handler</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">.&#160;</td>
          <td class="paramname"><em>assert_handler</em> = <code>rspq_assert_handler</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The RSPQ ucode </p>

</div>
</div>
<a id="aee149426cb6d86a71812a27b618d59c9" name="aee149426cb6d86a71812a27b618d59c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee149426cb6d86a71812a27b618d59c9">&#9670;&#160;</a></span>rspq_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the RSPQ library. </p>
<p>This should be called by the initialization functions of the higher-level libraries using the RSP command queue. It can be safely called multiple times without side effects.</p>
<p>It is not required by applications to call this explicitly in the main function. </p>

</div>
</div>
<a id="ad32f5f99467e9e5e7c7590e34a254d02" name="ad32f5f99467e9e5e7c7590e34a254d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32f5f99467e9e5e7c7590e34a254d02">&#9670;&#160;</a></span>rspq_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down the RSPQ library. </p>
<p>This is mainly used for testing. </p>

</div>
</div>
<a id="a24f709a49410891134670ee3a55ff27b" name="a24f709a49410891134670ee3a55ff27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f709a49410891134670ee3a55ff27b">&#9670;&#160;</a></span>rspq_overlay_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rspq_overlay_get_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *&#160;</td>
          <td class="paramname"><em>overlay_ucode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the overlay state (in RDRAM) </p>
<p>Overlays can define a section of DMEM as persistent state. This area will be preserved across overlay switching, by reading back into RDRAM the DMEM contents when the overlay is switched away.</p>
<p>This function returns a pointer to the state area in RDRAM (not DMEM). It is meant to modify the state on the CPU side while the overlay is not loaded. The layout of the state and its size should be known to the caller.</p>
<p>To avoid race conditions between overlay state access by CPU and RSP, this function first calls <a class="el" href="rspq_8h.html#af3055d289f73a125e15b72429cfc91ed" title="Wait until all commands in the queue have been executed by RSP.">rspq_wait</a> to force a full sync and make sure the RSP is idle. As such, it should be treated as a debugging function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlay_ucode</td><td>The ucode overlay for which the state pointer will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the overlay state (in RDRAM). The pointer is returned in the cached segment, so make sure to handle cache coherency appropriately. </dd></dl>

</div>
</div>
<a id="ad8d8f0c474f13dded0cf8bcc811ebc32" name="ad8d8f0c474f13dded0cf8bcc811ebc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d8f0c474f13dded0cf8bcc811ebc32">&#9670;&#160;</a></span>__rspq_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rspq__internal_8h.html#structrsp__queue__t">rsp_queue_t</a> * __rspq_get_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a copy of the current RSPQ state. </p>
<dl class="section note"><dt>Note</dt><dd>This function forces a full sync by calling <a class="el" href="rspq_8c.html#af3055d289f73a125e15b72429cfc91ed" title="Wait until all commands in the queue have been executed by RSP.">rspq_wait</a> to avoid race conditions. </dd></dl>

</div>
</div>
<a id="a072c51be5126cfe5f914aefc52de950a" name="a072c51be5126cfe5f914aefc52de950a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072c51be5126cfe5f914aefc52de950a">&#9670;&#160;</a></span>rspq_overlay_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rspq_overlay_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *&#160;</td>
          <td class="paramname"><em>overlay_ucode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a rspq overlay into the RSP queue engine. </p>
<p>This function registers a rspq overlay into the queue engine. An overlay is a RSP ucode that has been written to be compatible with the queue engine (see rsp_queue.inc for instructions) and is thus able to execute commands that are enqueued in the queue. An overlay doesn't have a single entry point: it exposes multiple functions bound to different commands, that will be called by the queue engine when the commands are enqueued.</p>
<p>The function returns the overlay ID, which is the ID to use to enqueue commands for this overlay. The overlay ID must be passed to <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> when adding new commands. rspq allows up to 16 overlays to be registered simultaneously, as the overlay ID occupies the top 4 bits of each command. The lower 4 bits specify the command ID, so in theory each overlay could offer a maximum of 16 commands. To overcome this limitation, this function will reserve multiple consecutive IDs in case an overlay with more than 16 commands is registered. These additional IDs are silently occupied and never need to be specified explicitly when queueing commands.</p>
<p>For example if an overlay with 32 commands were registered, this function could return ID 0x60, and ID 0x70 would implicitly be reserved as well. To queue the twenty first command of this overlay, you would write <code><a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write(ovl_id, 0x14, ...)</a></code>, where <code>ovl_id</code> is the value that was returned by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlay_ucode</td><td>The overlay to register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The overlay ID that has been assigned to the overlay. Note that this value will be preshifted by 28 (eg: 0x60000000 for ID 6), as this is the expected format used by <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>. </dd></dl>

</div>
</div>
<a id="a79bb76d8572e721cb4fdd322a6f6cb43" name="a79bb76d8572e721cb4fdd322a6f6cb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bb76d8572e721cb4fdd322a6f6cb43">&#9670;&#160;</a></span>rspq_overlay_register_static()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_overlay_register_static </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrsp__ucode__t.html">rsp_ucode_t</a> *&#160;</td>
          <td class="paramname"><em>overlay_ucode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>overlay_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an overlay into the RSP queue engine assigning a static ID to it. </p>
<p>This function works similar to <a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a>, except it will attempt to assign the specified ID to the overlay instead of automatically choosing one. Note that if the ID (or a consecutive IDs) is already used by another overlay, this function will assert, so careful usage is advised.</p>
<p>Assigning a static ID can mostly be useful for debugging purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlay_ucode</td><td>The ucode to register </td></tr>
    <tr><td class="paramname">overlay_id</td><td>The ID to register the overlay with. This ID must be preshifted by 28 (eg: 0x40000000).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a> </dd></dl>

</div>
</div>
<a id="a1e9b877ae18c66a9258c1b5d04c06e20" name="a1e9b877ae18c66a9258c1b5d04c06e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9b877ae18c66a9258c1b5d04c06e20">&#9670;&#160;</a></span>rspq_overlay_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_overlay_unregister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>overlay_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a ucode overlay from the RSP queue engine. </p>
<p>This function removes an overlay that has previously been registered with <a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a> or <a class="el" href="rspq_8h.html#a79bb76d8572e721cb4fdd322a6f6cb43" title="Register an overlay into the RSP queue engine assigning a static ID to it.">rspq_overlay_register_static</a> from the queue engine. After calling this function, the specified overlay ID (and consecutive IDs in case the overlay has more than 16 commands) is no longer valid and must not be used to write new commands into the queue.</p>
<p>Note that when new overlays are registered, the queue engine may recycle IDs from previously unregistered overlays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overlay_id</td><td>The ID of the ucode (as returned by <a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a>) to unregister. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d24ce57cd1b2cdb69297c97dab0eb21" name="a6d24ce57cd1b2cdb69297c97dab0eb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d24ce57cd1b2cdb69297c97dab0eb21">&#9670;&#160;</a></span>rspq_next_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_next_buffer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch to the next write buffer for the current RSP queue. </p>
<p>This function is invoked by <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> when the current buffer is full, that is, when the write pointer (<a class="el" href="rspq_8c.html#a721480d7b2d18bf1ad5b0d92c4b7e24b" title="Copy of the current write pointer (see rspq_ctx_t)">rspq_cur_pointer</a>) reaches the sentinel (<a class="el" href="rspq_8c.html#af6ef4eabdbb9a204474c2b7fe58975e8" title="Copy of the current write sentinel (see rspq_ctx_t)">rspq_cur_sentinel</a>). This means that we cannot safely write any more new command in the buffer (the remaining bytes are less than the maximum command size), and thus a new buffer must be configured.</p>
<p>If we're creating a block, we need to allocate a new buffer from the heap. Otherwise, if we're writing into either the lowpri or the highpri queue, we need to switch buffer (double buffering strategy), making sure the other buffer has been already fully executed by the RSP. </p>

</div>
</div>
<a id="a115e1839ffd27c126ed6076e2b5de0b8" name="a115e1839ffd27c126ed6076e2b5de0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115e1839ffd27c126ed6076e2b5de0b8">&#9670;&#160;</a></span>rspq_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure that RSP starts executing up to the last written command. </p>
<p>RSP processes the command queue asynchronously as it is being written. If it catches up with the CPU, it halts itself and waits for the CPU to notify that more commands are available. On the contrary, if the RSP lags behind it might keep executing commands as they are written without ever sleeping. So in general, at any given moment the RSP could be crunching commands or sleeping waiting to be notified that more commands are available.</p>
<p>This means that writing a command via <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> is not enough to make sure it is executed; depending on timing and batching performed by RSP, it might either be executed automatically or not. <a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a> makes sure that the RSP will see it and execute it.</p>
<p>This function does not block: it just make sure that the RSP will run the full command queue written until now. If you need to actively wait until the last written command has been executed, use <a class="el" href="rspq_8h.html#af3055d289f73a125e15b72429cfc91ed" title="Wait until all commands in the queue have been executed by RSP.">rspq_wait</a>.</p>
<p>It is suggested to call rspq_flush every time a new "batch" of commands has been written. In general, it is not a problem to call it often because it is very very fast (takes only ~20 cycles). For instance, it can be called after every rspq_write without many worries, but if you know that you are going to write a number of subsequent commands in straight line code, you can postpone the call to <a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a> after the whole sequence has been written.</p>
<div class="fragment"><div class="line">   <span class="comment">// This example shows some code configuring the lights for a scene.</span></div>
<div class="line">   <span class="comment">// The command in this sample is called CMD_SET_LIGHT and requires</span></div>
<div class="line">   <span class="comment">// a light index and the RGB colors for the list to update.</span></div>
<div class="line">uint32_t gfx_overlay_id;   </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">   #define CMD_SET_LIGHT  0x7</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;MAX_LIGHTS; i++) {</div>
<div class="line">       <a class="code hl_define" href="rspq_8h.html#aefec193be7de05f725738beeb3775634">rspq_write</a>(gfx_overlay_id, CMD_SET_LIGHT, i,</div>
<div class="line">           (lights[i].r &lt;&lt; 16) | (lights[i].g &lt;&lt; 8) | lights[i].b);</div>
<div class="line">   }</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// After enqueuing multiple commands, it is sufficient</span></div>
<div class="line">   <span class="comment">// to call rspq_flush once to make sure the RSP runs them (in case</span></div>
<div class="line">   <span class="comment">// it was idling).</span></div>
<div class="line">   <a class="code hl_function" href="rspq_8c.html#a115e1839ffd27c126ed6076e2b5de0b8">rspq_flush</a>();</div>
<div class="ttc" id="arspq_8c_html_a115e1839ffd27c126ed6076e2b5de0b8"><div class="ttname"><a href="rspq_8c.html#a115e1839ffd27c126ed6076e2b5de0b8">rspq_flush</a></div><div class="ttdeci">void rspq_flush(void)</div><div class="ttdoc">Make sure that RSP starts executing up to the last written command.</div><div class="ttdef"><b>Definition</b> rspq.c:1026</div></div>
<div class="ttc" id="arspq_8h_html_aefec193be7de05f725738beeb3775634"><div class="ttname"><a href="rspq_8h.html#aefec193be7de05f725738beeb3775634">rspq_write</a></div><div class="ttdeci">#define rspq_write(ovl_id, cmd_id,...)</div><div class="ttdoc">Write a new command into the RSP queue.</div><div class="ttdef"><b>Definition</b> rspq.h:397</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This is an experimental API. In the future, it might become a no-op, and flushing could happen automatically at every <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>. We are keeping it separate from <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> while experimenting more with the RSPQ API.</dd>
<dd>
This function is a no-op if it is called while a block is being recorded (see <a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> / <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a>). This means calling this function in a block recording context will not guarantee the execution of commands that were queued prior to starting the block. </dd></dl>

</div>
</div>
<a id="ae546104d15d469518ac5fba15521e965" name="ae546104d15d469518ac5fba15521e965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae546104d15d469518ac5fba15521e965">&#9670;&#160;</a></span>rspq_highpri_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_highpri_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start building a high-priority queue. </p>
<p>This function enters a special mode in which a high-priority queue is activated and can be filled with commands. After this function has been called, all commands will be put in the high-priority queue, until <a class="el" href="rspq_8h.html#ae495b6d8ec49169f05e523fe564f9f4b" title="Finish building the high-priority queue and close it.">rspq_highpri_end</a> is called.</p>
<p>The RSP will start processing the high-priority queue almost instantly (as soon as the current command is done), pausing the normal queue. This will also happen while the high-priority queue is being built, to achieve the lowest possible latency. When the RSP finishes processing the high priority queue (after <a class="el" href="rspq_8h.html#ae495b6d8ec49169f05e523fe564f9f4b" title="Finish building the high-priority queue and close it.">rspq_highpri_end</a> closes it), it resumes processing the normal queue from the exact point that was left.</p>
<p>The goal of the high-priority queue is to either schedule latency-sensitive commands like audio processing, or to schedule immediate RSP calculations that should be performed right away, just like they were preempting what the RSP is currently doing.</p>
<p>It is possible to create multiple high-priority queues by calling <a class="el" href="rspq_8h.html#ae546104d15d469518ac5fba15521e965" title="Start building a high-priority queue.">rspq_highpri_begin</a> / <a class="el" href="rspq_8h.html#ae495b6d8ec49169f05e523fe564f9f4b" title="Finish building the high-priority queue and close it.">rspq_highpri_end</a> multiple times with short delays in-between. The RSP will process them in order. Notice that there is a overhead in doing so, so it might be advisable to keep the high-priority mode active for a longer period if possible. On the other hand, a shorter high-priority queue allows for the RSP to switch back to processing the normal queue before the next one is created.</p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to create a block while the high-priority queue is active. Arrange for constructing blocks beforehand.</dd>
<dd>
It is currently not possible to call a block from the high-priority queue. (FIXME: to be implemented) </dd></dl>

</div>
</div>
<a id="ae495b6d8ec49169f05e523fe564f9f4b" name="ae495b6d8ec49169f05e523fe564f9f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae495b6d8ec49169f05e523fe564f9f4b">&#9670;&#160;</a></span>rspq_highpri_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_highpri_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish building the high-priority queue and close it. </p>
<p>This function terminates and closes the high-priority queue. After this command is called, all following commands will be added to the normal queue.</p>
<p>Notice that the RSP does not wait for this function to be called: it will start running the high-priority queue as soon as possible, even while it is being built. </p>

</div>
</div>
<a id="a577581d5bf9cfecaa6a1becf3da21d6c" name="a577581d5bf9cfecaa6a1becf3da21d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577581d5bf9cfecaa6a1becf3da21d6c">&#9670;&#160;</a></span>rspq_highpri_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_highpri_sync </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the RSP to finish processing all high-priority queues. </p>
<p>This function will spin-lock waiting for the RSP to finish processing all high-priority queues. It is meant for debugging purposes or for situations in which the high-priority queue is known to be very short and fast to run. Also note that it is not possible to create syncpoints in the high-priority queue. </p>

</div>
</div>
<a id="a41f292fc1f7b261f84c55fc356f86acf" name="a41f292fc1f7b261f84c55fc356f86acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f292fc1f7b261f84c55fc356f86acf">&#9670;&#160;</a></span>rspq_block_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_block_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin creating a new block. </p>
<p>This function begins writing a command block (see <a class="el" href="rspq__internal_8h.html#structrspq__block__t" title="A rspq block: pre-recorded array of commands.">rspq_block_t</a>). While a block is being written, all calls to <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> will record the commands into the block, without actually scheduling them for execution. Use <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a> to close the block and get a reference to it.</p>
<p>Only one block at a time can be created. Calling <a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> twice (without any intervening <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a>) will cause an assert.</p>
<p>During block creation, the RSP will keep running as usual and execute commands that have been already added to the queue.</p>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="rspq_8h.html#a115e1839ffd27c126ed6076e2b5de0b8" title="Make sure that RSP starts executing up to the last written command.">rspq_flush</a> are ignored during block creation, as the RSP is not going to execute the block commands anyway. </dd></dl>

</div>
</div>
<a id="a81339d69802148a09829d1c6d9a9f9f6" name="a81339d69802148a09829d1c6d9a9f9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81339d69802148a09829d1c6d9a9f9f6">&#9670;&#160;</a></span>rspq_block_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rspq__internal_8h.html#structrspq__block__t">rspq_block_t</a> * rspq_block_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish creating a block. </p>
<p>This function completes a block and returns a reference to it (see <a class="el" href="rspq__internal_8h.html#structrspq__block__t" title="A rspq block: pre-recorded array of commands.">rspq_block_t</a>). After this function is called, all subsequent <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> will resume working as usual: they will add commands to the queue for immediate RSP execution.</p>
<p>To run the created block, use <a class="el" href="rspq_8h.html#ad078c001303a1b2153ba99f3184194f3" title="Add to the RSP queue a command that runs a block.">rspq_block_run</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the just created block</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#ad078c001303a1b2153ba99f3184194f3" title="Add to the RSP queue a command that runs a block.">rspq_block_run</a> </dd></dl>

</div>
</div>
<a id="aa1d3fe8768ca839b49421bf08ac5b5c2" name="aa1d3fe8768ca839b49421bf08ac5b5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d3fe8768ca839b49421bf08ac5b5c2">&#9670;&#160;</a></span>rspq_block_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_block_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq__internal_8h.html#structrspq__block__t">rspq_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a block that is not needed any more. </p>
<p>After calling this function, the block is invalid and must not be called anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the block was being called by other blocks, these other blocks become invalid and will make the RSP crash if called. Make sure that freeing a block is only done when no other blocks reference it. </dd></dl>

</div>
</div>
<a id="ad078c001303a1b2153ba99f3184194f3" name="ad078c001303a1b2153ba99f3184194f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad078c001303a1b2153ba99f3184194f3">&#9670;&#160;</a></span>rspq_block_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_block_run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq__internal_8h.html#structrspq__block__t">rspq_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to the RSP queue a command that runs a block. </p>
<p>This function runs a block that was previously created via <a class="el" href="rspq_8h.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> and <a class="el" href="rspq_8h.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a>. It schedules a special command in the queue that will run the block, so that execution of the block will happen in order relative to other commands in the queue.</p>
<p>Blocks can call other blocks. For instance, if a block A has been fully created, it is possible to call <code>rspq_block_run(A)</code> at any point during the creation of a second block B; this means that B will contain the special command that will call A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block that must be run</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The maximum depth of nested block calls is 8. </dd></dl>

</div>
</div>
<a id="a5fa2fb070de8f3af2ee1a454a4db2bf4" name="a5fa2fb070de8f3af2ee1a454a4db2bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa2fb070de8f3af2ee1a454a4db2bf4">&#9670;&#160;</a></span>rspq_noop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_noop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a no-op command in the queue. </p>
<p>This function enqueues a command that does nothing. This is mostly useful for debugging purposes. </p>

</div>
</div>
<a id="a4d6fb26b5312a98ad83f758cd7514e6e" name="a4d6fb26b5312a98ad83f758cd7514e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6fb26b5312a98ad83f758cd7514e6e">&#9670;&#160;</a></span>rspq_syncpoint_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a> rspq_syncpoint_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a syncpoint in the queue. </p>
<p>This function creates a new "syncpoint" referencing the current position in the queue. It is possible to later check when the syncpoint is reached by the RSP via <a class="el" href="rspq_8h.html#a86e818e81e25912cddbb86672dcd9976" title="Check whether a syncpoint was reached by RSP or not.">rspq_syncpoint_check</a> and <a class="el" href="rspq_8h.html#ac3aa6ceb175fd56a5969fa01985e1d60" title="Wait until a syncpoint is reached by RSP.">rspq_syncpoint_wait</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>ID of the just-created syncpoint.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is not possible to create a syncpoint within a block because it is meant to be a one-time event. Otherwise the same syncpoint would potentially be triggered multiple times, which is not supported.</dd>
<dd>
It is not possible to create a syncpoint from the high-priority queue due to the implementation requiring syncpoints to be triggered in the same order they have been created.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf" title="A syncpoint in the queue.">rspq_syncpoint_t</a> </dd></dl>

</div>
</div>
<a id="a86e818e81e25912cddbb86672dcd9976" name="a86e818e81e25912cddbb86672dcd9976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e818e81e25912cddbb86672dcd9976">&#9670;&#160;</a></span>rspq_syncpoint_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rspq_syncpoint_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a>&#160;</td>
          <td class="paramname"><em>sync_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a syncpoint was reached by RSP or not. </p>
<p>This function checks whether a syncpoint was reached. It never blocks. If you need to wait for a syncpoint to be reached, use <a class="el" href="rspq_8h.html#ac3aa6ceb175fd56a5969fa01985e1d60" title="Wait until a syncpoint is reached by RSP.">rspq_syncpoint_wait</a> instead of polling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync_id</td><td>ID of the syncpoint to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the RSP has reached the syncpoint, false otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf" title="A syncpoint in the queue.">rspq_syncpoint_t</a> </dd></dl>

</div>
</div>
<a id="ac3aa6ceb175fd56a5969fa01985e1d60" name="ac3aa6ceb175fd56a5969fa01985e1d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3aa6ceb175fd56a5969fa01985e1d60">&#9670;&#160;</a></span>rspq_syncpoint_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_syncpoint_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf">rspq_syncpoint_t</a>&#160;</td>
          <td class="paramname"><em>sync_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until a syncpoint is reached by RSP. </p>
<p>This function blocks waiting for the RSP to reach the specified syncpoint. If the syncpoint was already called at the moment of call, the function exits immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync_id</td><td>ID of the syncpoint to wait for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a80d73a81524565e802d89bb14523b1cf" title="A syncpoint in the queue.">rspq_syncpoint_t</a> </dd></dl>

</div>
</div>
<a id="af3055d289f73a125e15b72429cfc91ed" name="af3055d289f73a125e15b72429cfc91ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3055d289f73a125e15b72429cfc91ed">&#9670;&#160;</a></span>rspq_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until all commands in the queue have been executed by RSP. </p>
<p>This function blocks until all commands present in the queue have been executed by the RSP and the RSP is idle. If the queue contained also RDP commands, it also waits for those commands to finish drawing.</p>
<p>This function exists mostly for debugging purposes. Calling this function is not necessary, as the CPU can continue adding commands to the queue while the RSP is running them. If you need to synchronize between RSP and CPU (eg: to access data that was processed by RSP) prefer using <a class="el" href="rspq_8h.html#a4d6fb26b5312a98ad83f758cd7514e6e" title="Create a syncpoint in the queue.">rspq_syncpoint_new</a> / <a class="el" href="rspq_8h.html#ac3aa6ceb175fd56a5969fa01985e1d60" title="Wait until a syncpoint is reached by RSP.">rspq_syncpoint_wait</a> which allows for more granular synchronization. </p>

</div>
</div>
<a id="af668e280d3621412dc28cbd59cf31ece" name="af668e280d3621412dc28cbd59cf31ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af668e280d3621412dc28cbd59cf31ece">&#9670;&#160;</a></span>rspq_dma_to_rdram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_dma_to_rdram </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rdram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dmem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a command to do a DMA transfer from DMEM to RDRAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">rdram_addr</td><td>The RDRAM address (destination, must be aligned to 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dmem_addr</td><td>The DMEM address (source, must be aligned to 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to transfer (must be multiple of 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_async</td><td>If true, the RSP does not wait for DMA completion and processes the next command as the DMA is in progress. If false, the RSP waits until the transfer is finished before processing the next command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The argument is_async refers to the RSP only. From the CPU standpoint, this function is always asynchronous as it just adds a command to the queue. </dd></dl>

</div>
</div>
<a id="ac49e7a85fa93aff13b9818615b5db977" name="ac49e7a85fa93aff13b9818615b5db977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49e7a85fa93aff13b9818615b5db977">&#9670;&#160;</a></span>rspq_dma_to_dmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_dma_to_dmem </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dmem_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rdram_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue a command to do a DMA transfer from RDRAM to DMEM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dmem_addr</td><td>The DMEM address (destination, must be aligned to 8) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rdram_addr</td><td>The RDRAM address (source, must be aligned to 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to transfer (must be multiple of 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_async</td><td>If true, the RSP does not wait for DMA completion and processes the next command as the DMA is in progress. If false, the RSP waits until the transfer is finished before processing the next command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The argument is_async refers to the RSP only. From the CPU standpoint, this function is always asynchronous as it just adds a command to the queue. </dd></dl>

</div>
</div>
<a id="a7853bba8cbf5773669b9e9ebd7f474cc" name="a7853bba8cbf5773669b9e9ebd7f474cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7853bba8cbf5773669b9e9ebd7f474cc">&#9670;&#160;</a></span>rspq_write_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a> rspq_write_begin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ovl_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin writing a new command into the RSP queue. </p>
<p>This command initiates a sequence to enqueue a new command into the RSP queue. Call this command passing the overlay ID and command ID of the command to create. Then, call <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> once per each argument word that composes the command. Finally, call <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> to finalize and enqueue the command.</p>
<p>A sequence made by <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a>, <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a>, <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> is functionally equivalent to a call to <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>, but it allows to create bigger commands, and might better fit some situations where arguments are calculated on the fly. Performance-wise, the code generated by <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> + <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> + <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> should be very similar to a single call to <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a>, though just a bit slower. It is advisable to use <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> whenever possible.</p>
<p>Make sure to read the documentation of <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> as well for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ovl_id</td><td>The overlay ID of the command to enqueue. Notice that this must be a value preshifted by 28, as returned by <a class="el" href="rspq_8h.html#a072c51be5126cfe5f914aefc52de950a" title="Register a rspq overlay into the RSP queue engine.">rspq_overlay_register</a>. </td></tr>
    <tr><td class="paramname">cmd_id</td><td>Index of the command to call, within the overlay. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the commands in 32-bit words </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A write cursor, that must be passed to <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> and <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> </dd></dl>

</div>
</div>
<a id="ab44674d8d8266f4a515b3fd4c6365b0b" name="ab44674d8d8266f4a515b3fd4c6365b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44674d8d8266f4a515b3fd4c6365b0b">&#9670;&#160;</a></span>rspq_write_arg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_write_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add one argument to the command being enqueued. </p>
<p>This function adds one more argument to the command currently being enqueued. This function must be called after <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a>; it should be called multiple times (one per argument word), and then <a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> should be called to terminate enqueuing the command.</p>
<p>See also <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> for a more straightforward API for command enqueuing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The write cursor (returned by <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a>) </td></tr>
    <tr><td class="paramname">value</td><td>New 32-bit argument word to add to the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The first argument must have its MSB set to 0, to leave space for the command ID. See <a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> documentation for a more complete explanation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#a08f96b9087b04fe6a5f224728ff47701" title="Finish enqueuing a command into the queue.">rspq_write_end</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> </dd></dl>

</div>
</div>
<a id="a08f96b9087b04fe6a5f224728ff47701" name="a08f96b9087b04fe6a5f224728ff47701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f96b9087b04fe6a5f224728ff47701">&#9670;&#160;</a></span>rspq_write_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rspq_write_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rspq_8h.html#structrspq__write__t">rspq_write_t</a> *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish enqueuing a command into the queue. </p>
<p>This function should be called to terminate a sequence for command enqueuing, after <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> and (multiple) calls to <a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a>.</p>
<p>After calling this command, the write cursor cannot be used anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The write cursor (returned by <a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rspq_8h.html#a7853bba8cbf5773669b9e9ebd7f474cc" title="Begin writing a new command into the RSP queue.">rspq_write_begin</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#ab44674d8d8266f4a515b3fd4c6365b0b" title="Add one argument to the command being enqueued.">rspq_write_arg</a> </dd>
<dd>
<a class="el" href="rspq_8h.html#aefec193be7de05f725738beeb3775634" title="Write a new command into the RSP queue.">rspq_write</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 13 2024 18:46:35 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
