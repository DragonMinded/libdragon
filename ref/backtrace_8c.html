<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: backtrace.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo2.png"/></td>
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">backtrace.c File Reference<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__lowlevel.html">Low Level Hardware Interfaces</a> &raquo; <a class="el" href="group__backtrace.html">Backtrace (call stack) support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Backtrace (call stack) support.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structsymtable__header__t" id="r_structsymtable__header__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="backtrace_8c.html#structsymtable__header__t">symtable_header_t</a></td></tr>
<tr class="memdesc:structsymtable__header__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol table file header.  <a href="backtrace_8c.html#structsymtable__header__t">More...</a><br /></td></tr>
<tr class="separator:structsymtable__header__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structsymtable__entry__t" id="r_structsymtable__entry__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="backtrace_8c.html#structsymtable__entry__t">symtable_entry_t</a></td></tr>
<tr class="memdesc:structsymtable__entry__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol table entry.  <a href="backtrace_8c.html#structsymtable__entry__t">More...</a><br /></td></tr>
<tr class="separator:structsymtable__entry__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0aafb83cc1e59b76159309e6c999437a" id="r_a0aafb83cc1e59b76159309e6c999437a"><td class="memItemLeft" align="right" valign="top"><a id="a0aafb83cc1e59b76159309e6c999437a" name="a0aafb83cc1e59b76159309e6c999437a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BACKTRACE_DEBUG</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a0aafb83cc1e59b76159309e6c999437a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable to debug why a backtrace is wrong. <br /></td></tr>
<tr class="separator:a0aafb83cc1e59b76159309e6c999437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfa885f92ac4859c340d39a3ac8cd48" id="r_afcfa885f92ac4859c340d39a3ac8cd48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="backtrace_8c.html#afcfa885f92ac4859c340d39a3ac8cd48">FUNCTION_ALIGNMENT</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:afcfa885f92ac4859c340d39a3ac8cd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function alignment enfored by the compiler (-falign-functions).  <br /></td></tr>
<tr class="separator:afcfa885f92ac4859c340d39a3ac8cd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cf8efc7fdabc9486c44535595030c5" id="r_a01cf8efc7fdabc9486c44535595030c5"><td class="memItemLeft" align="right" valign="top"><a id="a01cf8efc7fdabc9486c44535595030c5" name="a01cf8efc7fdabc9486c44535595030c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDRENTRY_ADDR</b>(e)&#160;&#160;&#160;((e) &amp; ~3)</td></tr>
<tr class="memdesc:a01cf8efc7fdabc9486c44535595030c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address (without the flags9) <br /></td></tr>
<tr class="separator:a01cf8efc7fdabc9486c44535595030c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd68e866c3ffb06406e76475595b1ac" id="r_aafd68e866c3ffb06406e76475595b1ac"><td class="memItemLeft" align="right" valign="top"><a id="aafd68e866c3ffb06406e76475595b1ac" name="aafd68e866c3ffb06406e76475595b1ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDRENTRY_IS_FUNC</b>(e)&#160;&#160;&#160;((e) &amp;  1)</td></tr>
<tr class="memdesc:aafd68e866c3ffb06406e76475595b1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the address is the start of a function. <br /></td></tr>
<tr class="separator:aafd68e866c3ffb06406e76475595b1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2304ae2d8f2a41b7ca9131491dd5330" id="r_af2304ae2d8f2a41b7ca9131491dd5330"><td class="memItemLeft" align="right" valign="top"><a id="af2304ae2d8f2a41b7ca9131491dd5330" name="af2304ae2d8f2a41b7ca9131491dd5330"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDRENTRY_IS_INLINE</b>(e)&#160;&#160;&#160;((e) &amp;  2)</td></tr>
<tr class="memdesc:af2304ae2d8f2a41b7ca9131491dd5330"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the address is an inline duplicate. <br /></td></tr>
<tr class="separator:af2304ae2d8f2a41b7ca9131491dd5330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bc4759a4b6d337210c9844acd305b1" id="r_ac8bc4759a4b6d337210c9844acd305b1"><td class="memItemLeft" align="right" valign="top"><a id="ac8bc4759a4b6d337210c9844acd305b1" name="ac8bc4759a4b6d337210c9844acd305b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIPS_OP_ADDIU_SP</b>(op)&#160;&#160;&#160;(((op) &amp; 0xFFFF0000) == 0x27BD0000)</td></tr>
<tr class="memdesc:ac8bc4759a4b6d337210c9844acd305b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches: addiu $sp, $sp, imm. <br /></td></tr>
<tr class="separator:ac8bc4759a4b6d337210c9844acd305b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2b2d8042b4eae33eb6987ed48ebeec" id="r_a3c2b2d8042b4eae33eb6987ed48ebeec"><td class="memItemLeft" align="right" valign="top"><a id="a3c2b2d8042b4eae33eb6987ed48ebeec" name="a3c2b2d8042b4eae33eb6987ed48ebeec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIPS_OP_DADDIU_SP</b>(op)&#160;&#160;&#160;(((op) &amp; 0xFFFF0000) == 0x67BD0000)</td></tr>
<tr class="memdesc:a3c2b2d8042b4eae33eb6987ed48ebeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches: daddiu $sp, $sp, imm. <br /></td></tr>
<tr class="separator:a3c2b2d8042b4eae33eb6987ed48ebeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa0fd6d8e5c9b73484fa5defe0cb641" id="r_abaa0fd6d8e5c9b73484fa5defe0cb641"><td class="memItemLeft" align="right" valign="top"><a id="abaa0fd6d8e5c9b73484fa5defe0cb641" name="abaa0fd6d8e5c9b73484fa5defe0cb641"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIPS_OP_JR_RA</b>(op)&#160;&#160;&#160;(((op) &amp; 0xFFFFFFFF) == 0x03E00008)</td></tr>
<tr class="memdesc:abaa0fd6d8e5c9b73484fa5defe0cb641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches: jr $ra. <br /></td></tr>
<tr class="separator:abaa0fd6d8e5c9b73484fa5defe0cb641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f4956597d8fae1c482452d175d72a1" id="r_a91f4956597d8fae1c482452d175d72a1"><td class="memItemLeft" align="right" valign="top"><a id="a91f4956597d8fae1c482452d175d72a1" name="a91f4956597d8fae1c482452d175d72a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIPS_OP_SD_RA_SP</b>(op)&#160;&#160;&#160;(((op) &amp; 0xFFFF0000) == 0xFFBF0000)</td></tr>
<tr class="memdesc:a91f4956597d8fae1c482452d175d72a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches: sd $ra, imm($sp) <br /></td></tr>
<tr class="separator:a91f4956597d8fae1c482452d175d72a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4005db26c4e8876c14094f0687932506" id="r_a4005db26c4e8876c14094f0687932506"><td class="memItemLeft" align="right" valign="top"><a id="a4005db26c4e8876c14094f0687932506" name="a4005db26c4e8876c14094f0687932506"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIPS_OP_SD_FP_SP</b>(op)&#160;&#160;&#160;(((op) &amp; 0xFFFF0000) == 0xFFBE0000)</td></tr>
<tr class="memdesc:a4005db26c4e8876c14094f0687932506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches: sd $fp, imm($sp) <br /></td></tr>
<tr class="separator:a4005db26c4e8876c14094f0687932506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0100e60bd74d46bff68a649be695bfb4" id="r_a0100e60bd74d46bff68a649be695bfb4"><td class="memItemLeft" align="right" valign="top"><a id="a0100e60bd74d46bff68a649be695bfb4" name="a0100e60bd74d46bff68a649be695bfb4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIPS_OP_LUI_GP</b>(op)&#160;&#160;&#160;(((op) &amp; 0xFFFF0000) == 0x3C1C0000)</td></tr>
<tr class="memdesc:a0100e60bd74d46bff68a649be695bfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches: lui $gp, imm. <br /></td></tr>
<tr class="separator:a0100e60bd74d46bff68a649be695bfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f9a5c825a583b912c50683a7927d64" id="r_ab1f9a5c825a583b912c50683a7927d64"><td class="memItemLeft" align="right" valign="top"><a id="ab1f9a5c825a583b912c50683a7927d64" name="ab1f9a5c825a583b912c50683a7927d64"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIPS_OP_NOP</b>(op)&#160;&#160;&#160;((op) == 0x00000000)</td></tr>
<tr class="memdesc:ab1f9a5c825a583b912c50683a7927d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches: nop. <br /></td></tr>
<tr class="separator:ab1f9a5c825a583b912c50683a7927d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b9dc08468b92535beeba8738812d2a" id="r_af4b9dc08468b92535beeba8738812d2a"><td class="memItemLeft" align="right" valign="top"><a id="af4b9dc08468b92535beeba8738812d2a" name="af4b9dc08468b92535beeba8738812d2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MIPS_OP_MOVE_FP_SP</b>(op)&#160;&#160;&#160;((op) == 0x03A0F025)</td></tr>
<tr class="memdesc:af4b9dc08468b92535beeba8738812d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches: move $fp, $sp. <br /></td></tr>
<tr class="separator:af4b9dc08468b92535beeba8738812d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae38bf1119cd5ea04fd439d2252ca6c3f" id="r_ae38bf1119cd5ea04fd439d2252ca6c3f"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="backtrace_8c.html#ae38bf1119cd5ea04fd439d2252ca6c3f">addrtable_entry_t</a></td></tr>
<tr class="memdesc:ae38bf1119cd5ea04fd439d2252ca6c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry in the address table.  <br /></td></tr>
<tr class="separator:ae38bf1119cd5ea04fd439d2252ca6c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acecc4685d595bbe1ceefe87ddb2f032e" id="r_acecc4685d595bbe1ceefe87ddb2f032e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="backtrace_8c.html#acecc4685d595bbe1ceefe87ddb2f032e">__symbolize</a> (void *vaddr, char *buf, int size)</td></tr>
<tr class="memdesc:acecc4685d595bbe1ceefe87ddb2f032e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symbol associated to a given address.  <br /></td></tr>
<tr class="separator:acecc4685d595bbe1ceefe87ddb2f032e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494fc6d2dd8e5e79b57c7a4a49d31afb" id="r_a494fc6d2dd8e5e79b57c7a4a49d31afb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="backtrace_8c.html#a494fc6d2dd8e5e79b57c7a4a49d31afb">__bt_analyze_func</a> (<a class="el" href="structbt__func__t.html">bt_func_t</a> *func, uint32_t *ptr, uint32_t func_start, bool from_exception)</td></tr>
<tr class="memdesc:a494fc6d2dd8e5e79b57c7a4a49d31afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze a function to find out its stack frame layout and properties (useful for backtracing).  <br /></td></tr>
<tr class="separator:a494fc6d2dd8e5e79b57c7a4a49d31afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3747bea884034d32d4d558872223969e" id="r_ga3747bea884034d32d4d558872223969e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__backtrace.html#ga3747bea884034d32d4d558872223969e">backtrace</a> (void **buffer, int size)</td></tr>
<tr class="memdesc:ga3747bea884034d32d4d558872223969e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the stack and return the current call stack.  <br /></td></tr>
<tr class="separator:ga3747bea884034d32d4d558872223969e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29121aee0428dbcf348d6218ad3c697c" id="r_ga29121aee0428dbcf348d6218ad3c697c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__backtrace.html#ga29121aee0428dbcf348d6218ad3c697c">backtrace_symbols_cb</a> (void **buffer, int size, uint32_t flags, void(*cb)(void *, <a class="el" href="group__backtrace.html#structbacktrace__frame__t">backtrace_frame_t</a> *), void *cb_arg)</td></tr>
<tr class="memdesc:ga29121aee0428dbcf348d6218ad3c697c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolize the buffer returned by <a class="el" href="group__backtrace.html#ga3747bea884034d32d4d558872223969e" title="Walk the stack and return the current call stack.">backtrace</a>, calling a callback for each frame.  <br /></td></tr>
<tr class="separator:ga29121aee0428dbcf348d6218ad3c697c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca2b35f3378753df6b8d2a2d48b8b9d9" id="r_gaca2b35f3378753df6b8d2a2d48b8b9d9"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__backtrace.html#gaca2b35f3378753df6b8d2a2d48b8b9d9">backtrace_symbols</a> (void **buffer, int size)</td></tr>
<tr class="memdesc:gaca2b35f3378753df6b8d2a2d48b8b9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the buffer returned by <a class="el" href="group__backtrace.html#ga3747bea884034d32d4d558872223969e" title="Walk the stack and return the current call stack.">backtrace</a> into a list of strings.  <br /></td></tr>
<tr class="separator:gaca2b35f3378753df6b8d2a2d48b8b9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga961ebc46193fd65a868daac8ecb16ce9" id="r_ga961ebc46193fd65a868daac8ecb16ce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__backtrace.html#ga961ebc46193fd65a868daac8ecb16ce9">backtrace_frame_print</a> (<a class="el" href="group__backtrace.html#structbacktrace__frame__t">backtrace_frame_t</a> *frame, FILE *out)</td></tr>
<tr class="memdesc:ga961ebc46193fd65a868daac8ecb16ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a single frame of a backtrace.  <br /></td></tr>
<tr class="separator:ga961ebc46193fd65a868daac8ecb16ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10fdf02abfdbf7d89d31eff0c0f106fb" id="r_ga10fdf02abfdbf7d89d31eff0c0f106fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__backtrace.html#ga10fdf02abfdbf7d89d31eff0c0f106fb">backtrace_frame_print_compact</a> (<a class="el" href="group__backtrace.html#structbacktrace__frame__t">backtrace_frame_t</a> *frame, FILE *out, int width)</td></tr>
<tr class="memdesc:ga10fdf02abfdbf7d89d31eff0c0f106fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a single frame of a backtrace, in a compact format.  <br /></td></tr>
<tr class="separator:ga10fdf02abfdbf7d89d31eff0c0f106fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac3d8f428d3773f4ca71242520d69aa8b" id="r_ac3d8f428d3773f4ca71242520d69aa8b"><td class="memItemLeft" align="right" valign="top"><a id="ac3d8f428d3773f4ca71242520d69aa8b" name="ac3d8f428d3773f4ca71242520d69aa8b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>inthandler</b> []</td></tr>
<tr class="memdesc:ac3d8f428d3773f4ca71242520d69aa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception handler (see inthandler.S) <br /></td></tr>
<tr class="separator:ac3d8f428d3773f4ca71242520d69aa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cccfc3a3401d1735cc73f85133c344" id="r_ac2cccfc3a3401d1735cc73f85133c344"><td class="memItemLeft" align="right" valign="top"><a id="ac2cccfc3a3401d1735cc73f85133c344" name="ac2cccfc3a3401d1735cc73f85133c344"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>inthandler_end</b> []</td></tr>
<tr class="memdesc:ac2cccfc3a3401d1735cc73f85133c344"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of exception handler (see inthandler.S) <br /></td></tr>
<tr class="separator:ac2cccfc3a3401d1735cc73f85133c344"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Backtrace (call stack) support. </p>
<p>This file contains the implementation of the backtrace support. See <a class="el" href="backtrace_8h.html" title="Backtrace (call stack) support.">backtrace.h</a> for an overview of the API. Here follows some implementation details.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Backtrace</h1>
<p>MIPS ABIs do not generally provide a way to walk the stack, as the frame pointer is not guaranteed to be present. It is possible to force its presence via "-fno-omit-frame-pointer", but we tried to provide a solution that works with standard compilation settings.</p>
<p>To perform backtracing, we scan the code backward starting from the return address of each frame. While scanning, we note some special instructions that we look for. The two main instructions that we look for are <code>sd ra, offset(sp)</code> which is used to save the previous return address to the stack, and <code>addiu sp, sp, offset</code> which creates the stack frame for the current function. When we find both, we know how to get back to the previous frame.</p>
<p>Notice that this also works through exceptions, as the exception handler does create a stack frame exactly like a standard function (see inthandler.S).</p>
<p>Only a few functions do use a frame pointer: those that allocate a runtime-calculated amount of stack (eg: using alloca). Because of this, we actually look for usages of the frame pointer register fp, and track those as well to be able to correctly walk the stack in those cases.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Symbolization</h1>
<p>To symbolize the backtrace, we use a symbol table file (SYMT) that is generated by the n64sym tool during the build process. The symbol table is put into the rompak (see <a class="el" href="rompak__internal_8h.html" title="ROM bundle support.">rompak_internal.h</a>) and is structured in a way that can be queried directly from ROM, without even allocating memory. This is especially useful to provide backtrace in catastrophic situations where the heap is not available.</p>
<p>The symbol table file contains the source code references (function name, file name, line number) for a number of addresses in the ROM. Since it would be impractical to save information for all the addresses in the text segment, only special addresses are saved: in particular, those where a function call is made (ie: the address of JAL / JALR instructions), which are the ones that are commonly found in backtraces and thus need to be symbolized. In addition to these, the symbol table contains also information associated to the addresses that mark the start of each function, so that it's always possible to infer the function a certain address belongs to.</p>
<p>Given that not all addresses are saved, it is important to provide accurate source code references for stack frames that are interrupted by interrupts or exceptions; in those cases, the symbolization will simply return the function name the addresses belongs to, without any source code reference.</p>
<p>To see more details on how the symbol table is structured in the ROM, see <a class="el" href="backtrace_8c.html#structsymtable__header__t" title="Symbol table file header.">symtable_header_t</a> and the source code of the n64sym tool. </p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structsymtable__header__t" id="structsymtable__header__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsymtable__header__t">&#9670;&#160;</a></span>symtable_header_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct symtable_header_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Symbol table file header. </p>
<p>The SYMT file is made of three main tables:</p>
<ul>
<li>Address table: this is a sequence of 32-bit integers, each representing an address in the ROM. The table is sorted in ascending order to allow for binary search. Moreover, the lowest 2 bits of each address can store additional information: If bit 0 is set to 1, the address is the start of a function. If bit 1 is set to 1, the address is an inline duplicate. In fact, there might be multiple symbols at the same address for inlined functions, so we need one entry in this table for each entry; all of them will have the same address, and all but the last one will have bit 1 set to 1.</li>
<li>Symbol table: this is a sequence of symbol table entries, each representing a symbol. The size of this table (in number of entries) is exactly the same as the address table. In fact, each address of the address table can be thought of as an external member of this structure; it's split externally to allow for efficiency reasons. Each entry stores the function name, the source file name and line number, and the binary offset of the symbol within the containing function.</li>
<li>String table: this table can be thought as a large buffer holding all the strings needed by all symbol entries (function names and file names). Each symbol entry stores a string as an offset within the symbol table and a length. This allows to reuse the same string (or prefix thereof) multiple times. Notice that strings are not null terminated in the string table.</li>
</ul>
<p>The SYMT file is generated by the n64sym tool during the build process. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="adc33a839e7349cce8bf1723fd5c32743" name="adc33a839e7349cce8bf1723fd5c32743"></a>char</td>
<td class="fieldname">
head[4]</td>
<td class="fielddoc">
Magic ID "SYMT". </td></tr>
<tr><td class="fieldtype">
<a id="a49df133ec55445f03fd42411feafd66c" name="a49df133ec55445f03fd42411feafd66c"></a>uint32_t</td>
<td class="fieldname">
version</td>
<td class="fielddoc">
Version of the symbol table. </td></tr>
<tr><td class="fieldtype">
<a id="ad54c656ef890c41d3aef1d4cb9936285" name="ad54c656ef890c41d3aef1d4cb9936285"></a>uint32_t</td>
<td class="fieldname">
addrtab_off</td>
<td class="fielddoc">
Offset of the address table in the file. </td></tr>
<tr><td class="fieldtype">
<a id="a4a1affd946e6ba60194be5b2604b0cf6" name="a4a1affd946e6ba60194be5b2604b0cf6"></a>uint32_t</td>
<td class="fieldname">
addrtab_size</td>
<td class="fielddoc">
Size of the address table in the file (number of entries) </td></tr>
<tr><td class="fieldtype">
<a id="aca6d27abacfd5ade148de0179ddae81f" name="aca6d27abacfd5ade148de0179ddae81f"></a>uint32_t</td>
<td class="fieldname">
symtab_off</td>
<td class="fielddoc">
Offset of the symbol table in the file. </td></tr>
<tr><td class="fieldtype">
<a id="ab3dc15a103b28648dd02e85a1daa4b1b" name="ab3dc15a103b28648dd02e85a1daa4b1b"></a>uint32_t</td>
<td class="fieldname">
symtab_size</td>
<td class="fielddoc">
Size of the symbol table in the file (number of entries); always equal to addrtab_size. </td></tr>
<tr><td class="fieldtype">
<a id="a893a547ee0bc544d145996f31af67828" name="a893a547ee0bc544d145996f31af67828"></a>uint32_t</td>
<td class="fieldname">
strtab_off</td>
<td class="fielddoc">
Offset of the string table in the file. </td></tr>
<tr><td class="fieldtype">
<a id="ae7a399bc6b29b56b70d427458e84f339" name="ae7a399bc6b29b56b70d427458e84f339"></a>uint32_t</td>
<td class="fieldname">
strtab_size</td>
<td class="fielddoc">
Size of the string table in the file (number of entries) </td></tr>
</table>

</div>
</div>
<a name="structsymtable__entry__t" id="structsymtable__entry__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsymtable__entry__t">&#9670;&#160;</a></span>symtable_entry_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct symtable_entry_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Symbol table entry. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a96f64766a4a52d04c399535670c2ac0b" name="a96f64766a4a52d04c399535670c2ac0b"></a>uint32_t</td>
<td class="fieldname">
func_sidx</td>
<td class="fielddoc">
Offset of the function name in the string table. </td></tr>
<tr><td class="fieldtype">
<a id="abccb99fc7524d975ff265aade9d1936f" name="abccb99fc7524d975ff265aade9d1936f"></a>uint32_t</td>
<td class="fieldname">
file_sidx</td>
<td class="fielddoc">
Offset of the file name in the string table. </td></tr>
<tr><td class="fieldtype">
<a id="acd3dbcd754d4bda72ff47ca971af1403" name="acd3dbcd754d4bda72ff47ca971af1403"></a>uint16_t</td>
<td class="fieldname">
func_len</td>
<td class="fielddoc">
Length of the function name. </td></tr>
<tr><td class="fieldtype">
<a id="ae0fb57aa791cb9b4180513c31598b8d9" name="ae0fb57aa791cb9b4180513c31598b8d9"></a>uint16_t</td>
<td class="fieldname">
file_len</td>
<td class="fielddoc">
Length of the file name. </td></tr>
<tr><td class="fieldtype">
<a id="a179e1f817956744078e63b251ff2aaa4" name="a179e1f817956744078e63b251ff2aaa4"></a>uint16_t</td>
<td class="fieldname">
line</td>
<td class="fielddoc">
Line number (or 0 if this symbol generically refers to a whole function) </td></tr>
<tr><td class="fieldtype">
<a id="a5211ea4344f6d10c033c58182f3f9fcb" name="a5211ea4344f6d10c033c58182f3f9fcb"></a>uint16_t</td>
<td class="fieldname">
func_off</td>
<td class="fielddoc">
Offset of the symbol within its function. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="afcfa885f92ac4859c340d39a3ac8cd48" name="afcfa885f92ac4859c340d39a3ac8cd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfa885f92ac4859c340d39a3ac8cd48">&#9670;&#160;</a></span>FUNCTION_ALIGNMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUNCTION_ALIGNMENT&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function alignment enfored by the compiler (-falign-functions). </p>
<dl class="section note"><dt>Note</dt><dd>This must be kept in sync with n64.mk. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae38bf1119cd5ea04fd439d2252ca6c3f" name="ae38bf1119cd5ea04fd439d2252ca6c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38bf1119cd5ea04fd439d2252ca6c3f">&#9670;&#160;</a></span>addrtable_entry_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="backtrace_8c.html#ae38bf1119cd5ea04fd439d2252ca6c3f">addrtable_entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry in the address table. </p>
<p>This is an address in RAM, with the lowest 2 bits used to store additional information. See the ADDRENTRY_* macros to access the various components. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acecc4685d595bbe1ceefe87ddb2f032e" name="acecc4685d595bbe1ceefe87ddb2f032e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecc4685d595bbe1ceefe87ddb2f032e">&#9670;&#160;</a></span>__symbolize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * __symbolize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the symbol associated to a given address. </p>
<p>This function inspect the symbol table (if any) to search for the specified address. It returns the function name the address belongs to, and the offset within the function as a string in the format "function_name+0x1234".</p>
<p>If the symbol table is not found in the rompack or the address is not found, the return string is "???".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>Address to symbolize </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer where to store the result </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* Pointer to the return string. This is within the provided buffer, but not necessarily at the beginning because of DMA alignment constraints. </dd></dl>

</div>
</div>
<a id="a494fc6d2dd8e5e79b57c7a4a49d31afb" name="a494fc6d2dd8e5e79b57c7a4a49d31afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494fc6d2dd8e5e79b57c7a4a49d31afb">&#9670;&#160;</a></span>__bt_analyze_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool __bt_analyze_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbt__func__t.html">bt_func_t</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>func_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_exception</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze a function to find out its stack frame layout and properties (useful for backtracing). </p>
<p>This function implements the core heuristic used by the backtrace engine. It analyzes the actual code of a function in memory instruction by instruction, trying to find out whether the function uses a stack frame or not, whether it uses a frame pointer, and where the return address is stored.</p>
<p>Since we do not have DWARF informations or similar metadata, we can just do educated guesses. A mistake in the heuristic will result probably in a wrong backtrace from this point on.</p>
<p>The heuristic works as follows:</p>
<ul>
<li>Most functions do have a stack frame. In fact, 99.99% of the functions you can find in a call stack must have a stack frame, because the only functions without a stack frame are leaf functions (functions that do not call other functions), which in turns can never be part of a stack trace.</li>
<li>The heuristic walks the function code backwards, looking for the stack frame. Specifically, it looks for an instruction saving the RA register to the stack (eg: <code>sd $ra, nn($sp)</code>), and an instruction creating the stack frame (eg: <code>addiu $sp, $sp, -nn</code>). Once both are found, the heuristic knows how to fill in <code>.stack_size</code> and <code>.ra_offset</code> fields of the function description structure, and it can stop.</li>
<li>Some functions also modify $fp (the frame pointer register): sometimes, they just use it as one additional free register, and other times they really use it as frame pointer. If the heuristic finds the instruction <code>move $fp, $sp</code>, it knows that the function uses $fp as frame pointer, and will mark the function as BT_FUNCTION_FRAMEPOINTER. In any case, the field <code>.fp_offset</code> will be filled in with the offset in the stack where $fp is stored, so that the backtrace engine can track the current value of the register in any case.</li>
<li>The 0.01% of the functions that do not have a stack frame but appear in the call stack are leaf functions interrupted by exceptions. Leaf functions pose two important problems: first, $ra is not saved into the stack so there is no way to know where to go back. Second, there is no clear indication where the function begins (as we normally stops analysis when we see the stack frame creation). So in this case the heuristic would fail. We rely thus on two hints coming from the caller:<ul>
<li>First, we expect the caller to set from_exception=true, so that we know that we might potentially deal with a leaf function.</li>
<li>Second, the caller should provide the function start address, so that we stop the analysis when we reach it, and mark the function as BT_LEAF.</li>
<li>If the function start address is not provided (because e.g. the symbol table was not found and thus we have no information about function starts), the last ditch heuristic is to look for the nops that are normally used to align the function start to the FUNCTION_ALIGNMENT boundary. Obviously this is a very fragile heuristic (it will fail if the function required no nops to be properly aligned), but it is the best we can do. Worst case, in this specific case of a leaf function interrupted by the exception, the stack trace will be wrong from this point on.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Output function description structure </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the function code at the point where the backtrace starts. This is normally the point where a JAL opcode is found, as we are walking up the call stack. </td></tr>
    <tr><td class="paramname">func_start</td><td>Start of the function being analyzed. This is optional: the heuristic can work without this hint, but it is useful in certain situations (eg: to better walk up after an exception). </td></tr>
    <tr><td class="paramname">from_exception</td><td>If true, this function was interrupted by an exception. This is a hint that the function <em>might</em> even be a leaf function without a stack frame, and that we must use special heuristics for it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the backtrace can continue, false if must be aborted (eg: we are within invalid memory) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 13 2024 18:48:02 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
