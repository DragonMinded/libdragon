<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: Audio Subsystem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo2.png"/></td>
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Audio Subsystem<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Interface to the N64 audio hardware.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__mixer" id="r_group__mixer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mixer.html">Audio mixer</a></td></tr>
<tr class="memdesc:group__mixer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flexible, composable, fast, RSP-based audio mixer. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:audio_8c" id="r_audio_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="audio_8c.html">audio.c</a></td></tr>
<tr class="memdesc:audio_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio Subsystem. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:audio_8h" id="r_audio_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="audio_8h.html">audio.h</a></td></tr>
<tr class="memdesc:audio_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio Subsystem. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaecfbc74a751594695ce3706d199da203" id="r_gaecfbc74a751594695ce3706d199da203"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#gaecfbc74a751594695ce3706d199da203">audio_fill_buffer_callback</a>) (short *buffer, size_t numsamples)</td></tr>
<tr class="memdesc:gaecfbc74a751594695ce3706d199da203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will be called periodically when more sample data is needed.  <br /></td></tr>
<tr class="separator:gaecfbc74a751594695ce3706d199da203"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8ef2eb966a8552f3d19526753b98427f" id="r_ga8ef2eb966a8552f3d19526753b98427f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f">audio_init</a> (const int frequency, int numbuffers)</td></tr>
<tr class="memdesc:ga8ef2eb966a8552f3d19526753b98427f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the audio subsystem.  <br /></td></tr>
<tr class="separator:ga8ef2eb966a8552f3d19526753b98427f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga456542c1cf5d749b2a351778f932f7a6" id="r_ga456542c1cf5d749b2a351778f932f7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga456542c1cf5d749b2a351778f932f7a6">audio_set_buffer_callback</a> (<a class="el" href="group__audio.html#gaecfbc74a751594695ce3706d199da203">audio_fill_buffer_callback</a> fill_buffer_callback)</td></tr>
<tr class="memdesc:ga456542c1cf5d749b2a351778f932f7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a audio callback to fill the audio buffer when required.  <br /></td></tr>
<tr class="separator:ga456542c1cf5d749b2a351778f932f7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977622d0345b9951d9259d5ff202de8c" id="r_ga977622d0345b9951d9259d5ff202de8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga977622d0345b9951d9259d5ff202de8c">audio_pause</a> (bool pause)</td></tr>
<tr class="memdesc:ga977622d0345b9951d9259d5ff202de8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause or resume audio playback.  <br /></td></tr>
<tr class="separator:ga977622d0345b9951d9259d5ff202de8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762b8b0c8957798c66ee158ce513e05e" id="r_ga762b8b0c8957798c66ee158ce513e05e"><td class="memItemLeft" align="right" valign="top">volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e">audio_can_write</a> ()</td></tr>
<tr class="memdesc:ga762b8b0c8957798c66ee158ce513e05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether there is an empty buffer to write to.  <br /></td></tr>
<tr class="separator:ga762b8b0c8957798c66ee158ce513e05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c6a38d6ce470872e4016ecc6d9abd3" id="r_gad0c6a38d6ce470872e4016ecc6d9abd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#gad0c6a38d6ce470872e4016ecc6d9abd3">audio_write_silence</a> ()</td></tr>
<tr class="memdesc:gad0c6a38d6ce470872e4016ecc6d9abd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a chunk of silence.  <br /></td></tr>
<tr class="separator:gad0c6a38d6ce470872e4016ecc6d9abd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad927b510bc46c3e0ebcfae81706fec06" id="r_gad927b510bc46c3e0ebcfae81706fec06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#gad927b510bc46c3e0ebcfae81706fec06">audio_close</a> ()</td></tr>
<tr class="memdesc:gad927b510bc46c3e0ebcfae81706fec06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the audio subsystem.  <br /></td></tr>
<tr class="separator:gad927b510bc46c3e0ebcfae81706fec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6892c9dfdd99e00a4285fe05058d6a37" id="r_ga6892c9dfdd99e00a4285fe05058d6a37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga6892c9dfdd99e00a4285fe05058d6a37">audio_get_frequency</a> ()</td></tr>
<tr class="memdesc:ga6892c9dfdd99e00a4285fe05058d6a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return actual frequency of audio playback.  <br /></td></tr>
<tr class="separator:ga6892c9dfdd99e00a4285fe05058d6a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12decba34a007365bf749874e044b88d" id="r_ga12decba34a007365bf749874e044b88d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga12decba34a007365bf749874e044b88d">audio_get_buffer_length</a> ()</td></tr>
<tr class="memdesc:ga12decba34a007365bf749874e044b88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of stereo samples that fit into an allocated buffer.  <br /></td></tr>
<tr class="separator:ga12decba34a007365bf749874e044b88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aee840f13aa6903fef4c092d0ffa704" id="r_ga8aee840f13aa6903fef4c092d0ffa704"><td class="memItemLeft" align="right" valign="top">short *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#ga8aee840f13aa6903fef4c092d0ffa704">audio_write_begin</a> (void)</td></tr>
<tr class="memdesc:ga8aee840f13aa6903fef4c092d0ffa704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start writing to the first free internal buffer.  <br /></td></tr>
<tr class="separator:ga8aee840f13aa6903fef4c092d0ffa704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac872c4749acb1685ebeabc1f9d02c0bf" id="r_gac872c4749acb1685ebeabc1f9d02c0bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#gac872c4749acb1685ebeabc1f9d02c0bf">audio_write_end</a> (void)</td></tr>
<tr class="memdesc:gac872c4749acb1685ebeabc1f9d02c0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete writing to an internal buffer.  <br /></td></tr>
<tr class="separator:gac872c4749acb1685ebeabc1f9d02c0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc52546c0036b0fe9023d9588500a1e1" id="r_gabc52546c0036b0fe9023d9588500a1e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#gabc52546c0036b0fe9023d9588500a1e1">audio_push</a> (const short *buffer, int nsamples, bool blocking)</td></tr>
<tr class="memdesc:gabc52546c0036b0fe9023d9588500a1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a chunk of audio data (high-level function)  <br /></td></tr>
<tr class="separator:gabc52546c0036b0fe9023d9588500a1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06cc34952ebf6952af37f7080743c98" id="r_gab06cc34952ebf6952af37f7080743c98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__audio.html#gab06cc34952ebf6952af37f7080743c98">audio_write</a> (const short *const buffer)</td></tr>
<tr class="memdesc:gab06cc34952ebf6952af37f7080743c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a chunk of audio data.  <br /></td></tr>
<tr class="separator:gab06cc34952ebf6952af37f7080743c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Interface to the N64 audio hardware. </p>
<p>The audio subsystem handles queueing up chunks of audio data for playback using the N64 audio DAC. The audio subsystem handles DMAing chunks of data to the audio DAC as well as audio callbacks when there is room for another chunk to be written. Buffer size is calculated automatically based on the requested audio frequency. The audio subsystem accomplishes this by interfacing with the audio interface (AI) registers.</p>
<p>Because the audio DAC is timed off of the system clock of the N64, the audio subsystem needs to know what region the N64 is from. This is due to the fact that the system clock is timed differently for PAL, NTSC and MPAL regions. This is handled automatically by the audio subsystem based on settings left by the bootloader.</p>
<p>Code attempting to output audio on the N64 should initialize the audio subsystem at the desired frequency and with the desired number of buffers using <a class="el" href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f" title="Initialize the audio subsystem.">audio_init</a>. More audio buffers allows for smaller chances of audio glitches but means that there will be more latency in sound output. When new data is available to be output, code should check to see if there is room in the output buffers using <a class="el" href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e" title="Return whether there is an empty buffer to write to.">audio_can_write</a>. Code can probe the current frequency and buffer size using <a class="el" href="group__audio.html#ga6892c9dfdd99e00a4285fe05058d6a37" title="Return actual frequency of audio playback.">audio_get_frequency</a> and <a class="el" href="group__audio.html#ga12decba34a007365bf749874e044b88d" title="Get the number of stereo samples that fit into an allocated buffer.">audio_get_buffer_length</a> respectively. When there is additional room, code can add new data to the output buffers using <a class="el" href="group__audio.html#gab06cc34952ebf6952af37f7080743c98" title="Write a chunk of audio data.">audio_write</a>. Be careful as this is a blocking operation, so if code doesn't check for adequate room first, this function will not return until there is room and the samples have been written. When all audio has been written, code should call <a class="el" href="group__audio.html#gad927b510bc46c3e0ebcfae81706fec06" title="Close the audio subsystem.">audio_close</a> to shut down the audio subsystem cleanly. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaecfbc74a751594695ce3706d199da203" name="gaecfbc74a751594695ce3706d199da203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecfbc74a751594695ce3706d199da203">&#9670;&#160;</a></span>audio_fill_buffer_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* audio_fill_buffer_callback) (short *buffer, size_t numsamples)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will be called periodically when more sample data is needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The address to write the sample data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numsamples</td><td>The number of samples to write to the buffer</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: This is the number of samples per channel, so clients should write twice this number of samples (interleaved). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8ef2eb966a8552f3d19526753b98427f" name="ga8ef2eb966a8552f3d19526753b98427f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ef2eb966a8552f3d19526753b98427f">&#9670;&#160;</a></span>audio_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_init </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the audio subsystem. </p>
<p>This function will set up the AI to play at a given frequency and allocate a number of back buffers to write data to.</p>
<dl class="section note"><dt>Note</dt><dd>Before re-initializing the audio subsystem to a new playback frequency, remember to call <a class="el" href="group__audio.html#gad927b510bc46c3e0ebcfae81706fec06" title="Close the audio subsystem.">audio_close</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frequency</td><td>The frequency in Hz to play back samples at </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numbuffers</td><td>The number of buffers to allocate internally </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga456542c1cf5d749b2a351778f932f7a6" name="ga456542c1cf5d749b2a351778f932f7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga456542c1cf5d749b2a351778f932f7a6">&#9670;&#160;</a></span>audio_set_buffer_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_set_buffer_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__audio.html#gaecfbc74a751594695ce3706d199da203">audio_fill_buffer_callback</a>&#160;</td>
          <td class="paramname"><em>fill_buffer_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a audio callback to fill the audio buffer when required. </p>
<p>This function allows to implement a pull-based audio system. It registers a callback which will be invoked under interrupt whenever the AI is ready to have more samples enqueued. The callback can fill the provided audio data with samples that will be enqueued for DMA to AI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fill_buffer_callback</td><td>Callback to fill an empty audio buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga977622d0345b9951d9259d5ff202de8c" name="ga977622d0345b9951d9259d5ff202de8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga977622d0345b9951d9259d5ff202de8c">&#9670;&#160;</a></span>audio_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_pause </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause or resume audio playback. </p>
<p>Should only be used when a fill_buffer_callback has been set in <a class="el" href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f" title="Initialize the audio subsystem.">audio_init</a>. Silence will be generated while playback is paused. </p>

</div>
</div>
<a id="ga762b8b0c8957798c66ee158ce513e05e" name="ga762b8b0c8957798c66ee158ce513e05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762b8b0c8957798c66ee158ce513e05e">&#9670;&#160;</a></span>audio_can_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile int audio_can_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether there is an empty buffer to write to. </p>
<p>This function will check to see if there are any buffers that are not full to write data to. If all buffers are full, wait until the AI has played back the next buffer in its queue and try writing again. </p>

</div>
</div>
<a id="gad0c6a38d6ce470872e4016ecc6d9abd3" name="gad0c6a38d6ce470872e4016ecc6d9abd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0c6a38d6ce470872e4016ecc6d9abd3">&#9670;&#160;</a></span>audio_write_silence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_write_silence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a chunk of silence. </p>
<p>This function will write silence to be played back by the audio system. It writes exactly <a class="el" href="group__audio.html#ga12decba34a007365bf749874e044b88d" title="Get the number of stereo samples that fit into an allocated buffer.">audio_get_buffer_length</a> stereo samples.</p>
<dl class="section note"><dt>Note</dt><dd>This function will block until there is room to write an audio sample. If you do not want to block, check to see if there is room by calling <a class="el" href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e" title="Return whether there is an empty buffer to write to.">audio_can_write</a>. </dd></dl>

</div>
</div>
<a id="gad927b510bc46c3e0ebcfae81706fec06" name="gad927b510bc46c3e0ebcfae81706fec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad927b510bc46c3e0ebcfae81706fec06">&#9670;&#160;</a></span>audio_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the audio subsystem. </p>
<p>This function closes the audio system and cleans up any internal memory allocated by <a class="el" href="group__audio.html#ga8ef2eb966a8552f3d19526753b98427f" title="Initialize the audio subsystem.">audio_init</a>. </p>

</div>
</div>
<a id="ga6892c9dfdd99e00a4285fe05058d6a37" name="ga6892c9dfdd99e00a4285fe05058d6a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6892c9dfdd99e00a4285fe05058d6a37">&#9670;&#160;</a></span>audio_get_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int audio_get_frequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return actual frequency of audio playback. </p>
<dl class="section return"><dt>Returns</dt><dd>Frequency in Hz of the audio playback </dd></dl>

</div>
</div>
<a id="ga12decba34a007365bf749874e044b88d" name="ga12decba34a007365bf749874e044b88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12decba34a007365bf749874e044b88d">&#9670;&#160;</a></span>audio_get_buffer_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int audio_get_buffer_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of stereo samples that fit into an allocated buffer. </p>
<dl class="section note"><dt>Note</dt><dd>To get the number of bytes to allocate, multiply the return by 2 * sizeof( short )</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of stereo samples in an allocated buffer </dd></dl>

</div>
</div>
<a id="ga8aee840f13aa6903fef4c092d0ffa704" name="ga8aee840f13aa6903fef4c092d0ffa704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aee840f13aa6903fef4c092d0ffa704">&#9670;&#160;</a></span>audio_write_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short * audio_write_begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start writing to the first free internal buffer. </p>
<p>This function is similar to <a class="el" href="group__audio.html#gab06cc34952ebf6952af37f7080743c98" title="Write a chunk of audio data.">audio_write</a> but instead of taking samples and copying them to an internal buffer, it returns the pointer to the internal buffer. This allows generating the samples directly in the buffer that will be sent via DMA to AI, without any subsequent memory copy.</p>
<p>The buffer should be filled with stereo interleaved samples, and exactly <a class="el" href="group__audio.html#ga12decba34a007365bf749874e044b88d" title="Get the number of stereo samples that fit into an allocated buffer.">audio_get_buffer_length</a> samples should be written.</p>
<p>After you have written the samples, call <a class="el" href="group__audio.html#gac872c4749acb1685ebeabc1f9d02c0bf" title="Complete writing to an internal buffer.">audio_write_end()</a> to notify the library that the buffer is ready to be sent to AI.</p>
<dl class="section note"><dt>Note</dt><dd>This function will block until there is room to write an audio sample. If you do not want to block, check to see if there is room by calling <a class="el" href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e" title="Return whether there is an empty buffer to write to.">audio_can_write</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the internal memory buffer where to write samples. </dd></dl>

</div>
</div>
<a id="gac872c4749acb1685ebeabc1f9d02c0bf" name="gac872c4749acb1685ebeabc1f9d02c0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac872c4749acb1685ebeabc1f9d02c0bf">&#9670;&#160;</a></span>audio_write_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_write_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete writing to an internal buffer. </p>
<p>This function is meant to be used in pair with <a class="el" href="group__audio.html#ga8aee840f13aa6903fef4c092d0ffa704" title="Start writing to the first free internal buffer.">audio_write_begin()</a>. Call this once you have generated the samples, so that the audio system knows the buffer has been filled and can be played back. </p>

</div>
</div>
<a id="gabc52546c0036b0fe9023d9588500a1e1" name="gabc52546c0036b0fe9023d9588500a1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc52546c0036b0fe9023d9588500a1e1">&#9670;&#160;</a></span>audio_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int audio_push </td>
          <td>(</td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nsamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push a chunk of audio data (high-level function) </p>
<p>This function is an easy-to-use, higher level alternative to all the audio_write* functions. It pushes audio samples into output hiding the complexity required to match the fixed-size audio buffers.</p>
<p>The function accepts a <code>buffer</code> of stereo interleaved audio samples; <code>nsamples</code> is the number of samples in the buffer. The function will push the samples into output as much as possible.</p>
<p>If <code>blocking</code> is true, it will stop and wait until all samples have been pushed into output. If <code>blocking</code> is false, it will stop as soon as there are no more free buffers to push samples into, and will return the number of pushed samples. It is up to the caller to then take care of this and later try to call audio_push again with the remaining samples.</p>
<dl class="section note"><dt>Note</dt><dd>You CANNOT mixmatch this function with the other audio_write* functions, and viceversa. If you decide to use audio_push, use it exclusively to push the audio.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer containing stereo samples to be played </td></tr>
    <tr><td class="paramname">nsamples</td><td>Number of stereo samples in the buffer </td></tr>
    <tr><td class="paramname">blocking</td><td>If true, wait until all samples have been pushed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Number of samples pushed into output </dd></dl>

</div>
</div>
<a id="gab06cc34952ebf6952af37f7080743c98" name="gab06cc34952ebf6952af37f7080743c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab06cc34952ebf6952af37f7080743c98">&#9670;&#160;</a></span>audio_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void audio_write </td>
          <td>(</td>
          <td class="paramtype">const short *const&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a chunk of audio data. </p>
<p>This function takes a chunk of audio data and writes it to an internal buffer which will be played back by the audio system as soon as room becomes available in the AI. The buffer should contain stereo interleaved samples and be exactly <a class="el" href="group__audio.html#ga12decba34a007365bf749874e044b88d" title="Get the number of stereo samples that fit into an allocated buffer.">audio_get_buffer_length</a> stereo samples long.</p>
<p>To improve performance and avoid the memory copy, use <a class="el" href="group__audio.html#ga8aee840f13aa6903fef4c092d0ffa704" title="Start writing to the first free internal buffer.">audio_write_begin</a> and <a class="el" href="group__audio.html#gac872c4749acb1685ebeabc1f9d02c0bf" title="Complete writing to an internal buffer.">audio_write_end</a> instead.</p>
<dl class="section note"><dt>Note</dt><dd>This function will block until there is room to write an audio sample. If you do not want to block, check to see if there is room by calling <a class="el" href="group__audio.html#ga762b8b0c8957798c66ee158ce513e05e" title="Return whether there is an empty buffer to write to.">audio_can_write</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Buffer containing stereo samples to be played </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 11 2024 19:58:15 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
