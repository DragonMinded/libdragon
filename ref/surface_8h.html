<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdragon: surface.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo2.png"/></td>
  <td id="projectalign">
   <div id="projectname">libdragon
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">surface.h File Reference<div class="ingroups"><a class="el" href="group__libdragon.html">libdragon</a> &raquo; <a class="el" href="group__display.html">Display Subsystem</a> &raquo; <a class="el" href="group__graphics.html">2D Graphics</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Surface buffers used to draw images.  
<a href="#details">More...</a></p>

<p><a href="surface_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structsurface__t" id="r_structsurface__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a></td></tr>
<tr class="memdesc:structsurface__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">A surface buffer for graphics.  <a href="surface_8h.html#structsurface__t">More...</a><br /></td></tr>
<tr class="separator:structsurface__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ade664cca1cdac41a2e9380bdbb98cfd8" id="r_ade664cca1cdac41a2e9380bdbb98cfd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#ade664cca1cdac41a2e9380bdbb98cfd8">TEX_FORMAT_BITDEPTH</a>(fmt)&#160;&#160;&#160;(4 &lt;&lt; ((fmt) &amp; 0x3))</td></tr>
<tr class="memdesc:ade664cca1cdac41a2e9380bdbb98cfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the depth (number of bits per pixel) from a <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1" title="Pixel format enum.">tex_format_t</a>. (eg: <code>FMT_RGBA16</code> =&gt; 16)  <br /></td></tr>
<tr class="separator:ade664cca1cdac41a2e9380bdbb98cfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82925c45165d62752b7520fe74ed7fa9" id="r_a82925c45165d62752b7520fe74ed7fa9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#a82925c45165d62752b7520fe74ed7fa9">TEX_FORMAT_PIX2BYTES</a>(fmt,  pixels)&#160;&#160;&#160;((((pixels) &lt;&lt; (((fmt) &amp; 3) + 2)) + 7) &gt;&gt; 3)</td></tr>
<tr class="memdesc:a82925c45165d62752b7520fe74ed7fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the specified number of pixels to bytes.  <br /></td></tr>
<tr class="separator:a82925c45165d62752b7520fe74ed7fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d266c460ce7974103858f37f8921c67" id="r_a3d266c460ce7974103858f37f8921c67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#a3d266c460ce7974103858f37f8921c67">TEX_FORMAT_BYTES2PIX</a>(fmt,  bytes)&#160;&#160;&#160;(((bytes) &lt;&lt; 1) &gt;&gt; ((fmt) &amp; 3))</td></tr>
<tr class="memdesc:a3d266c460ce7974103858f37f8921c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the specified number of bytes to pixels.  <br /></td></tr>
<tr class="separator:a3d266c460ce7974103858f37f8921c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af987b5a73ec05cead979f8295555b666" id="r_af987b5a73ec05cead979f8295555b666"><td class="memItemLeft" align="right" valign="top"><a id="af987b5a73ec05cead979f8295555b666" name="af987b5a73ec05cead979f8295555b666"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SURFACE_FLAGS_TEXFORMAT</b>&#160;&#160;&#160;0x001F</td></tr>
<tr class="memdesc:af987b5a73ec05cead979f8295555b666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pixel format of the surface. <br /></td></tr>
<tr class="separator:af987b5a73ec05cead979f8295555b666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0fb0cf02521629354df1b07091be4f" id="r_a1c0fb0cf02521629354df1b07091be4f"><td class="memItemLeft" align="right" valign="top"><a id="a1c0fb0cf02521629354df1b07091be4f" name="a1c0fb0cf02521629354df1b07091be4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SURFACE_FLAGS_OWNEDBUFFER</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a1c0fb0cf02521629354df1b07091be4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set if the buffer must be freed. <br /></td></tr>
<tr class="separator:a1c0fb0cf02521629354df1b07091be4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8834b7841c0b42bdba9db6e482f1b2" id="r_a7d8834b7841c0b42bdba9db6e482f1b2"><td class="memItemLeft" align="right" valign="top"><a id="a7d8834b7841c0b42bdba9db6e482f1b2" name="a7d8834b7841c0b42bdba9db6e482f1b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SURFACE_FLAGS_TEXINDEX</b>&#160;&#160;&#160;0x0F00</td></tr>
<tr class="memdesc:a7d8834b7841c0b42bdba9db6e482f1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for rdpq lookup table. <br /></td></tr>
<tr class="separator:a7d8834b7841c0b42bdba9db6e482f1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a01f43f3d6c80a7658bf729bfaf3136e1" id="r_a01f43f3d6c80a7658bf729bfaf3136e1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a> { <br />
&#160;&#160;<a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1a7a2840ab7f7a839b7792f61a5da8f14a">FMT_NONE</a> = 0
, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1ae781a51949044f96a872ca8e2715bed5">FMT_RGBA16</a> = _RDP_FORMAT_CODE(0, 2)
, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1a0ae35df0b9a28b002380dc866dad303a">FMT_RGBA32</a> = _RDP_FORMAT_CODE(0, 3)
, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1a303eb8a72aa1cd29e0314012f5bae6d3">FMT_YUV16</a> = _RDP_FORMAT_CODE(1, 2)
, <br />
&#160;&#160;<a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1ae7c884ef15b16d8bb1fe78d46aa209c4">FMT_CI4</a> = _RDP_FORMAT_CODE(2, 0)
, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1a1d1f3cf5eb79947c79274c2a353e86aa">FMT_CI8</a> = _RDP_FORMAT_CODE(2, 1)
, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1a4ff892513378c8a5a574d16c4407fc02">FMT_IA4</a> = _RDP_FORMAT_CODE(3, 0)
, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1aec32ce49add48c326830f22588d374a3">FMT_IA8</a> = _RDP_FORMAT_CODE(3, 1)
, <br />
&#160;&#160;<a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1a78cfb6783fde72099d6263fdbc9be114">FMT_IA16</a> = _RDP_FORMAT_CODE(3, 2)
, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1aea193e8909772b3a4f178c544ee05fd1">FMT_I4</a> = _RDP_FORMAT_CODE(4, 0)
, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1a7845dc9354faccf8262e271b1026b0f2">FMT_I8</a> = _RDP_FORMAT_CODE(4, 1)
<br />
 }</td></tr>
<tr class="memdesc:a01f43f3d6c80a7658bf729bfaf3136e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pixel format enum.  <a href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">More...</a><br /></td></tr>
<tr class="separator:a01f43f3d6c80a7658bf729bfaf3136e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae533cf98566a3ff542e8a9af92e177b3" id="r_ae533cf98566a3ff542e8a9af92e177b3"><td class="memItemLeft" align="right" valign="top"><a id="ae533cf98566a3ff542e8a9af92e177b3" name="ae533cf98566a3ff542e8a9af92e177b3"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>tex_format_name</b> (<a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a> fmt)</td></tr>
<tr class="memdesc:ae533cf98566a3ff542e8a9af92e177b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the texture format as a string (for debugging purposes) <br /></td></tr>
<tr class="separator:ae533cf98566a3ff542e8a9af92e177b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bd38809ff7938c1d0123d540a2851a" id="r_a47bd38809ff7938c1d0123d540a2851a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#a47bd38809ff7938c1d0123d540a2851a">surface_make</a> (void *buffer, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a> format, uint16_t width, uint16_t height, uint16_t stride)</td></tr>
<tr class="memdesc:a47bd38809ff7938c1d0123d540a2851a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> structure with the provided buffer.  <br /></td></tr>
<tr class="separator:a47bd38809ff7938c1d0123d540a2851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3b32ed02cfdd4927fea56e3f84e280" id="r_a9f3b32ed02cfdd4927fea56e3f84e280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#a9f3b32ed02cfdd4927fea56e3f84e280">surface_make_linear</a> (void *buffer, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a> format, uint16_t width, uint16_t height)</td></tr>
<tr class="memdesc:a9f3b32ed02cfdd4927fea56e3f84e280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> structure with the provided linear buffer.  <br /></td></tr>
<tr class="separator:a9f3b32ed02cfdd4927fea56e3f84e280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a48f2ccc890381490463097d6f51c93" id="r_a5a48f2ccc890381490463097d6f51c93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#a5a48f2ccc890381490463097d6f51c93">surface_alloc</a> (<a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a> format, uint16_t width, uint16_t height)</td></tr>
<tr class="memdesc:a5a48f2ccc890381490463097d6f51c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new surface in memory.  <br /></td></tr>
<tr class="separator:a5a48f2ccc890381490463097d6f51c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201a14d89649b0f81ef8d535b724b34f" id="r_a201a14d89649b0f81ef8d535b724b34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#a201a14d89649b0f81ef8d535b724b34f">surface_make_sub</a> (<a class="el" href="surface_8h.html#structsurface__t">surface_t</a> *parent, uint16_t x0, uint16_t y0, uint16_t width, uint16_t height)</td></tr>
<tr class="memdesc:a201a14d89649b0f81ef8d535b724b34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> structure, pointing to a rectangular portion of another surface.  <br /></td></tr>
<tr class="separator:a201a14d89649b0f81ef8d535b724b34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7940ed434b55044bf078472f59173e" id="r_abb7940ed434b55044bf078472f59173e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#abb7940ed434b55044bf078472f59173e">surface_free</a> (<a class="el" href="surface_8h.html#structsurface__t">surface_t</a> *surface)</td></tr>
<tr class="memdesc:abb7940ed434b55044bf078472f59173e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the buffer allocated in a surface.  <br /></td></tr>
<tr class="separator:abb7940ed434b55044bf078472f59173e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87295c49590f004305ce1d5e36e42f7" id="r_af87295c49590f004305ce1d5e36e42f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#af87295c49590f004305ce1d5e36e42f7">surface_get_format</a> (const <a class="el" href="surface_8h.html#structsurface__t">surface_t</a> *surface)</td></tr>
<tr class="memdesc:af87295c49590f004305ce1d5e36e42f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pixel format of a surface.  <br /></td></tr>
<tr class="separator:af87295c49590f004305ce1d5e36e42f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0366404adb987076f9b28e34cc15820b" id="r_a0366404adb987076f9b28e34cc15820b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#a0366404adb987076f9b28e34cc15820b">surface_has_owned_buffer</a> (const <a class="el" href="surface_8h.html#structsurface__t">surface_t</a> *surface)</td></tr>
<tr class="memdesc:a0366404adb987076f9b28e34cc15820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this surface owns the buffer that it contains.  <br /></td></tr>
<tr class="separator:a0366404adb987076f9b28e34cc15820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade63b26694a75b09506d5fd9cf35e670" id="r_ade63b26694a75b09506d5fd9cf35e670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#ade63b26694a75b09506d5fd9cf35e670">surface_make_placeholder</a> (int index, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a> format, uint16_t width, uint16_t height, uint16_t stride)</td></tr>
<tr class="memdesc:ade63b26694a75b09506d5fd9cf35e670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a placeholder surface, that can be used during rdpq block recording.  <br /></td></tr>
<tr class="separator:ade63b26694a75b09506d5fd9cf35e670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c6f76ee9f39cc668e6628cc1fb46ef" id="r_a72c6f76ee9f39cc668e6628cc1fb46ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#a72c6f76ee9f39cc668e6628cc1fb46ef">surface_make_placeholder_linear</a> (int index, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a> format, uint16_t width, uint16_t height)</td></tr>
<tr class="memdesc:a72c6f76ee9f39cc668e6628cc1fb46ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a linear placeholder surface, that can be used during rdpq block recording.  <br /></td></tr>
<tr class="separator:a72c6f76ee9f39cc668e6628cc1fb46ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3cbb3a8c49dba329cd9c816c152825" id="r_a4f3cbb3a8c49dba329cd9c816c152825"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="surface_8h.html#a4f3cbb3a8c49dba329cd9c816c152825">surface_get_placeholder_index</a> (const <a class="el" href="surface_8h.html#structsurface__t">surface_t</a> *surface)</td></tr>
<tr class="memdesc:a4f3cbb3a8c49dba329cd9c816c152825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lookup index of a placeholder surface.  <br /></td></tr>
<tr class="separator:a4f3cbb3a8c49dba329cd9c816c152825"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Surface buffers used to draw images. </p>
<p>This module implements a structure <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> which holds the basic information for a buffer of memory to be used for graphics rendering.</p>
<p>A surface is described by the following properties:</p>
<ul>
<li>Size (width, height)</li>
<li>Pixel format</li>
<li>Stride (distance in bytes between rows)</li>
</ul>
<p><a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> simply represents an aggregation of these properties.</p>
<p>To allocate a new surface, use <a class="el" href="surface_8h.html#a5a48f2ccc890381490463097d6f51c93" title="Allocate a new surface in memory.">surface_alloc</a>. Then later, you can release the memory using <a class="el" href="surface_8h.html#abb7940ed434b55044bf078472f59173e" title="Free the buffer allocated in a surface.">surface_free</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Allocate a 64x64 buffer in RGBA 16-bit format</span></div>
<div class="line"><a class="code hl_struct" href="surface_8h.html#structsurface__t">surface_t</a> buf = <a class="code hl_function" href="surface_8c.html#a5a48f2ccc890381490463097d6f51c93">surface_alloc</a>(<a class="code hl_enumvalue" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1ae781a51949044f96a872ca8e2715bed5">FMT_RGBA16</a>, 64, 64);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Draw some text on it (with the CPU)</span></div>
<div class="line"><a class="code hl_function" href="group__graphics.html#gaf3f2f465571daf68282f4e293d04cfce">graphics_draw_text</a>(&amp;buf, 0, 0, <span class="stringliteral">&quot;ABC&quot;</span>);</div>
<div class="ttc" id="agroup__graphics_html_gaf3f2f465571daf68282f4e293d04cfce"><div class="ttname"><a href="group__graphics.html#gaf3f2f465571daf68282f4e293d04cfce">graphics_draw_text</a></div><div class="ttdeci">void graphics_draw_text(surface_t *disp, int x, int y, const char *const msg)</div><div class="ttdoc">Draw a null terminated string to a display context.</div><div class="ttdef"><b>Definition</b> graphics.c:593</div></div>
<div class="ttc" id="asurface_8c_html_a5a48f2ccc890381490463097d6f51c93"><div class="ttname"><a href="surface_8c.html#a5a48f2ccc890381490463097d6f51c93">surface_alloc</a></div><div class="ttdeci">surface_t surface_alloc(tex_format_t format, uint16_t width, uint16_t height)</div><div class="ttdoc">Allocate a new surface in memory.</div><div class="ttdef"><b>Definition</b> surface.c:32</div></div>
<div class="ttc" id="asurface_8h_html_a01f43f3d6c80a7658bf729bfaf3136e1ae781a51949044f96a872ca8e2715bed5"><div class="ttname"><a href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1ae781a51949044f96a872ca8e2715bed5">FMT_RGBA16</a></div><div class="ttdeci">@ FMT_RGBA16</div><div class="ttdoc">Format RGBA 5551 (16-bit)</div><div class="ttdef"><b>Definition</b> surface.h:106</div></div>
<div class="ttc" id="asurface_8h_html_structsurface__t"><div class="ttname"><a href="surface_8h.html#structsurface__t">surface_t</a></div><div class="ttdoc">A surface buffer for graphics.</div><div class="ttdef"><b>Definition</b> surface.h:138</div></div>
</div><!-- fragment --><p>Sometimes, you might have an existing raw pointer to a buffer and need to pass it to an API that accepts a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a>. For those cases, you can use <a class="el" href="surface_8h.html#a47bd38809ff7938c1d0123d540a2851a" title="Initialize a surface_t structure with the provided buffer.">surface_make</a> to create a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> instance, that you can throw away after you called the function; <a class="el" href="surface_8h.html#abb7940ed434b55044bf078472f59173e" title="Free the buffer allocated in a surface.">surface_free</a> does nothing on these surfaces.</p>
<p>In some cases, you might want to interact with a rectangular portion of an existing surface (for instance, you want to draw with RDP only in the top portion of the screen for some reason). To do so, you can use <a class="el" href="surface_8h.html#a201a14d89649b0f81ef8d535b724b34f" title="Initialize a surface_t structure, pointing to a rectangular portion of another surface.">surface_make_sub</a> to create a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> instance that is referring only to a portion of the original surface:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="surface_8h.html#structsurface__t">surface_t</a> *fb = <a class="code hl_function" href="group__display.html#gaf8ad0501f0408430e3b40f0f626a33bd">display_get</a>();  <span class="comment">// wait for a framebuffer to be ready</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attach the RDP to the top 40 rows of the framebuffer</span></div>
<div class="line"><a class="code hl_struct" href="surface_8h.html#structsurface__t">surface_t</a> fbtop = <a class="code hl_function" href="surface_8c.html#a201a14d89649b0f81ef8d535b724b34f">surface_make_sub</a>(fb, 0, 0, 320, 40);</div>
<div class="line"><a class="code hl_function" href="rdpq__attach_8c.html#a67bd7bcd3d71538f5a10d50ba73b6b10">rdpq_attach</a>(&amp;fbtop);</div>
<div class="ttc" id="agroup__display_html_gaf8ad0501f0408430e3b40f0f626a33bd"><div class="ttname"><a href="group__display.html#gaf8ad0501f0408430e3b40f0f626a33bd">display_get</a></div><div class="ttdeci">surface_t * display_get(void)</div><div class="ttdoc">Get a display buffer for rendering.</div><div class="ttdef"><b>Definition</b> display.c:326</div></div>
<div class="ttc" id="ardpq__attach_8c_html_a67bd7bcd3d71538f5a10d50ba73b6b10"><div class="ttname"><a href="rdpq__attach_8c.html#a67bd7bcd3d71538f5a10d50ba73b6b10">rdpq_attach</a></div><div class="ttdeci">void rdpq_attach(const surface_t *surf_color, const surface_t *surf_z)</div><div class="ttdoc">Attach the RDP to a color surface (and optionally a Z buffer)</div><div class="ttdef"><b>Definition</b> rdpq_attach.c:76</div></div>
<div class="ttc" id="asurface_8c_html_a201a14d89649b0f81ef8d535b724b34f"><div class="ttname"><a href="surface_8c.html#a201a14d89649b0f81ef8d535b724b34f">surface_make_sub</a></div><div class="ttdeci">surface_t surface_make_sub(surface_t *parent, uint16_t x0, uint16_t y0, uint16_t width, uint16_t height)</div><div class="ttdoc">Initialize a surface_t structure, pointing to a rectangular portion of another surface.</div><div class="ttdef"><b>Definition</b> surface.c:57</div></div>
</div><!-- fragment --><p>Surfaces created by <a class="el" href="surface_8h.html#a201a14d89649b0f81ef8d535b724b34f" title="Initialize a surface_t structure, pointing to a rectangular portion of another surface.">surface_make_sub</a> don't need to be freed as they are just references to the parent surface; <a class="el" href="surface_8h.html#abb7940ed434b55044bf078472f59173e" title="Free the buffer allocated in a surface.">surface_free</a> does nothing on them. </p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structsurface__t" id="structsurface__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structsurface__t">&#9670;&#160;</a></span>surface_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct surface_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A surface buffer for graphics. </p>
<p>This structure holds the basic information about a buffer used to hold graphics. It is commonly used by graphics routines in libdragon as either a source (eg: texture) or a target (eg: framebuffer). It can be used for both CPU-based drawing (such as <a class="el" href="graphics_8h.html" title="2D Graphics">graphics.h</a>) or RDP-basic drawing (such as <a class="el" href="rdp_8h.html" title="RDP: Hardware Display Interface.">rdp.h</a> and <a class="el" href="rdpq_8h.html" title="RDP Command queue.">rdpq.h</a>).</p>
<p>Use <a class="el" href="surface_8c.html#a5a48f2ccc890381490463097d6f51c93" title="Allocate a new surface in memory.">surface_alloc</a> / <a class="el" href="surface_8c.html#abb7940ed434b55044bf078472f59173e" title="Free the buffer allocated in a surface.">surface_free</a> to allocate / free a surface. If you already have a memory pointer to a graphics buffer and you just need to wrap it in a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a>, use <a class="el" href="surface_8c.html#a47bd38809ff7938c1d0123d540a2851a" title="Initialize a surface_t structure with the provided buffer.">surface_make</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="afcf076b028b981bcdce9637481ba6ab2" name="afcf076b028b981bcdce9637481ba6ab2"></a>uint16_t</td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
Flags (including pixel format) </td></tr>
<tr><td class="fieldtype">
<a id="a4da37c9b386a4740ef024d3eb33bd090" name="a4da37c9b386a4740ef024d3eb33bd090"></a>uint16_t</td>
<td class="fieldname">
width</td>
<td class="fielddoc">
Width in pixels. </td></tr>
<tr><td class="fieldtype">
<a id="a95e005f68eb2625d2207f3fbe1702794" name="a95e005f68eb2625d2207f3fbe1702794"></a>uint16_t</td>
<td class="fieldname">
height</td>
<td class="fielddoc">
Height in pixels. </td></tr>
<tr><td class="fieldtype">
<a id="a072aa5060cd760944f530653f2f7f161" name="a072aa5060cd760944f530653f2f7f161"></a>uint16_t</td>
<td class="fieldname">
stride</td>
<td class="fielddoc">
Stride in bytes (length of a row) </td></tr>
<tr><td class="fieldtype">
<a id="a44186bab3de93b8be2c9ae6328dfb8b9" name="a44186bab3de93b8be2c9ae6328dfb8b9"></a>void *</td>
<td class="fieldname">
buffer</td>
<td class="fielddoc">
Buffer pointer. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ade664cca1cdac41a2e9380bdbb98cfd8" name="ade664cca1cdac41a2e9380bdbb98cfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade664cca1cdac41a2e9380bdbb98cfd8">&#9670;&#160;</a></span>TEX_FORMAT_BITDEPTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEX_FORMAT_BITDEPTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fmt</td><td>)</td>
          <td>&#160;&#160;&#160;(4 &lt;&lt; ((fmt) &amp; 0x3))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the depth (number of bits per pixel) from a <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1" title="Pixel format enum.">tex_format_t</a>. (eg: <code>FMT_RGBA16</code> =&gt; 16) </p>
<p>Note that there are texture format that are 4bpp, so don't divide this by 8 to get the number of bytes per pixels, but rather use <a class="el" href="surface_8h.html#a3d266c460ce7974103858f37f8921c67" title="Convert the specified number of bytes to pixels.">TEX_FORMAT_BYTES2PIX</a> and <a class="el" href="surface_8h.html#a82925c45165d62752b7520fe74ed7fa9" title="Convert the specified number of pixels to bytes.">TEX_FORMAT_PIX2BYTES</a>. </p>

</div>
</div>
<a id="a82925c45165d62752b7520fe74ed7fa9" name="a82925c45165d62752b7520fe74ed7fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82925c45165d62752b7520fe74ed7fa9">&#9670;&#160;</a></span>TEX_FORMAT_PIX2BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEX_FORMAT_PIX2BYTES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pixels&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((((pixels) &lt;&lt; (((fmt) &amp; 3) + 2)) + 7) &gt;&gt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the specified number of pixels to bytes. </p>
<dl class="section note"><dt>Note</dt><dd>This macro rounds up the value. For 4bpp surfaces, this means that it returns the safe number of bytes that can hold the specified number of pixels. For instance, <code><a class="el" href="surface_8h.html#a82925c45165d62752b7520fe74ed7fa9" title="Convert the specified number of pixels to bytes.">TEX_FORMAT_PIX2BYTES(FMT_CI4, 3)</a></code> returns 2, as you need 2 bytes to store 3 pixels in 4bpp format (even though the last byte is only half used). </dd></dl>

</div>
</div>
<a id="a3d266c460ce7974103858f37f8921c67" name="a3d266c460ce7974103858f37f8921c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d266c460ce7974103858f37f8921c67">&#9670;&#160;</a></span>TEX_FORMAT_BYTES2PIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEX_FORMAT_BYTES2PIX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bytes&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((bytes) &lt;&lt; 1) &gt;&gt; ((fmt) &amp; 3))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the specified number of bytes to pixels. </p>
<dl class="section note"><dt>Note</dt><dd>This macro rounds down the value. For instance, for a 32-bpp surface, calling <code><a class="el" href="surface_8h.html#a3d266c460ce7974103858f37f8921c67" title="Convert the specified number of bytes to pixels.">TEX_FORMAT_BYTES2PIX(FMT_RGBA32, 5)</a></code> returns 1, because you can safely store at maximum 1 32bpp pixel in 5 bytes. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a01f43f3d6c80a7658bf729bfaf3136e1" name="a01f43f3d6c80a7658bf729bfaf3136e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f43f3d6c80a7658bf729bfaf3136e1">&#9670;&#160;</a></span>tex_format_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pixel format enum. </p>
<p>This enum defines the pixel formats that can be used for <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> buffers. The list corresponds to the pixel formats that the RDP can use as textures.</p>
<dl class="section note"><dt>Note</dt><dd>Some of these formats can be used by RDP as framebuffer (specifically, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1ae781a51949044f96a872ca8e2715bed5" title="Format RGBA 5551 (16-bit)">FMT_RGBA16</a>, <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1a0ae35df0b9a28b002380dc866dad303a" title="Format RGBA 8888 (32-bit)">FMT_RGBA32</a> and <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1a1d1f3cf5eb79947c79274c2a353e86aa" title="Format CI8: color index 8-bit (paletted, 1 index per byte)">FMT_CI8</a>). </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the CPU-based graphics library <a class="el" href="graphics_8h.html" title="2D Graphics">graphics.h</a> only accepts surfaces in either <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1ae781a51949044f96a872ca8e2715bed5" title="Format RGBA 5551 (16-bit)">FMT_RGBA16</a> or <a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1a0ae35df0b9a28b002380dc866dad303a" title="Format RGBA 8888 (32-bit)">FMT_RGBA32</a> as target buffers, and does not assert. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1a7a2840ab7f7a839b7792f61a5da8f14a" name="a01f43f3d6c80a7658bf729bfaf3136e1a7a2840ab7f7a839b7792f61a5da8f14a"></a>FMT_NONE&#160;</td><td class="fielddoc"><p>Placeholder for no format defined. </p>
</td></tr>
<tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1ae781a51949044f96a872ca8e2715bed5" name="a01f43f3d6c80a7658bf729bfaf3136e1ae781a51949044f96a872ca8e2715bed5"></a>FMT_RGBA16&#160;</td><td class="fielddoc"><p>Format RGBA 5551 (16-bit) </p>
</td></tr>
<tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1a0ae35df0b9a28b002380dc866dad303a" name="a01f43f3d6c80a7658bf729bfaf3136e1a0ae35df0b9a28b002380dc866dad303a"></a>FMT_RGBA32&#160;</td><td class="fielddoc"><p>Format RGBA 8888 (32-bit) </p>
</td></tr>
<tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1a303eb8a72aa1cd29e0314012f5bae6d3" name="a01f43f3d6c80a7658bf729bfaf3136e1a303eb8a72aa1cd29e0314012f5bae6d3"></a>FMT_YUV16&#160;</td><td class="fielddoc"><p>Format YUV2 4:2:2 (data interleaved as YUYV) </p>
</td></tr>
<tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1ae7c884ef15b16d8bb1fe78d46aa209c4" name="a01f43f3d6c80a7658bf729bfaf3136e1ae7c884ef15b16d8bb1fe78d46aa209c4"></a>FMT_CI4&#160;</td><td class="fielddoc"><p>Format CI4: color index 4-bit (paletted, 2 indices per byte) </p>
</td></tr>
<tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1a1d1f3cf5eb79947c79274c2a353e86aa" name="a01f43f3d6c80a7658bf729bfaf3136e1a1d1f3cf5eb79947c79274c2a353e86aa"></a>FMT_CI8&#160;</td><td class="fielddoc"><p>Format CI8: color index 8-bit (paletted, 1 index per byte) </p>
</td></tr>
<tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1a4ff892513378c8a5a574d16c4407fc02" name="a01f43f3d6c80a7658bf729bfaf3136e1a4ff892513378c8a5a574d16c4407fc02"></a>FMT_IA4&#160;</td><td class="fielddoc"><p>Format IA4: 3-bit intensity + 1-bit alpha (4-bit per pixel) </p>
</td></tr>
<tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1aec32ce49add48c326830f22588d374a3" name="a01f43f3d6c80a7658bf729bfaf3136e1aec32ce49add48c326830f22588d374a3"></a>FMT_IA8&#160;</td><td class="fielddoc"><p>Format IA8: 4-bit intensity + 4-bit alpha (8-bit per pixel) </p>
</td></tr>
<tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1a78cfb6783fde72099d6263fdbc9be114" name="a01f43f3d6c80a7658bf729bfaf3136e1a78cfb6783fde72099d6263fdbc9be114"></a>FMT_IA16&#160;</td><td class="fielddoc"><p>Format IA16: 8-bit intensity + 8-bit alpha (16-bit per pixel) </p>
</td></tr>
<tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1aea193e8909772b3a4f178c544ee05fd1" name="a01f43f3d6c80a7658bf729bfaf3136e1aea193e8909772b3a4f178c544ee05fd1"></a>FMT_I4&#160;</td><td class="fielddoc"><p>Format I4: 4-bit intensity (4-bit per pixel) </p>
</td></tr>
<tr><td class="fieldname"><a id="a01f43f3d6c80a7658bf729bfaf3136e1a7845dc9354faccf8262e271b1026b0f2" name="a01f43f3d6c80a7658bf729bfaf3136e1a7845dc9354faccf8262e271b1026b0f2"></a>FMT_I8&#160;</td><td class="fielddoc"><p>Format I8: 8-bit intensity (8-bit per pixel) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a47bd38809ff7938c1d0123d540a2851a" name="a47bd38809ff7938c1d0123d540a2851a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bd38809ff7938c1d0123d540a2851a">&#9670;&#160;</a></span>surface_make()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a> surface_make </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> structure with the provided buffer. </p>
<p>This functions initializes a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> structure with the provided buffer and information. It is just a helper to fill the structure fields.</p>
<p>It is not necessary to call <a class="el" href="surface_8h.html#abb7940ed434b55044bf078472f59173e" title="Free the buffer allocated in a surface.">surface_free</a> on surfaces created by <a class="el" href="surface_8h.html#a47bd38809ff7938c1d0123d540a2851a" title="Initialize a surface_t structure with the provided buffer.">surface_make</a> as there is nothing to free: the provided buffer will not be owned by the structure, so it is up to the caller to handle its lifetime.</p>
<p>If you plan to use this format as RDP framebuffer, make sure that the provided buffer respects the required alignment of 64 bytes, otherwise <a class="el" href="rdpq__attach_8c.html#a67bd7bcd3d71538f5a10d50ba73b6b10" title="Attach the RDP to a color surface (and optionally a Z buffer)">rdpq_attach</a> will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the memory buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Pixel format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width in pixels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height in pixels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stride</td><td>Stride in bytes (length of a row) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The initialized surface</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="surface_8h.html#a9f3b32ed02cfdd4927fea56e3f84e280" title="Initialize a surface_t structure with the provided linear buffer.">surface_make_linear</a> </dd></dl>

</div>
</div>
<a id="a9f3b32ed02cfdd4927fea56e3f84e280" name="a9f3b32ed02cfdd4927fea56e3f84e280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3b32ed02cfdd4927fea56e3f84e280">&#9670;&#160;</a></span>surface_make_linear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a> surface_make_linear </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> structure with the provided linear buffer. </p>
<p>This function is similar to <a class="el" href="surface_8h.html#a47bd38809ff7938c1d0123d540a2851a" title="Initialize a surface_t structure with the provided buffer.">surface_make</a>, but it works for images that are linearly mapped with no per-line padding or extraneous data.</p>
<p>Compared to <a class="el" href="surface_8h.html#a47bd38809ff7938c1d0123d540a2851a" title="Initialize a surface_t structure with the provided buffer.">surface_make</a>, it does not accept a stride parameter, and calculate the stride from the width and the pixel format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the memory buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Pixel format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width in pixels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height in pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The initialized surface</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="surface_8h.html#a47bd38809ff7938c1d0123d540a2851a" title="Initialize a surface_t structure with the provided buffer.">surface_make</a> </dd></dl>

</div>
</div>
<a id="a5a48f2ccc890381490463097d6f51c93" name="a5a48f2ccc890381490463097d6f51c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a48f2ccc890381490463097d6f51c93">&#9670;&#160;</a></span>surface_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a> surface_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new surface in memory. </p>
<p>This function allocates a new surface with the specified pixel format, width and height. The surface must be freed via <a class="el" href="surface_8h.html#abb7940ed434b55044bf078472f59173e" title="Free the buffer allocated in a surface.">surface_free</a> when it is not needed anymore.</p>
<p>A surface allocated via <a class="el" href="surface_8h.html#a5a48f2ccc890381490463097d6f51c93" title="Allocate a new surface in memory.">surface_alloc</a> can be used as a RDP frame buffer (passed to <a class="el" href="rdpq__attach_8c.html#a67bd7bcd3d71538f5a10d50ba73b6b10" title="Attach the RDP to a color surface (and optionally a Z buffer)">rdpq_attach</a>) because it is guaranteed to have the required alignment of 64 bytes, provided it is using one of the formats supported by RDP as a framebuffer target (<code>FMT_RGBA32</code>, <code>FMT_RGBA16</code> or <code>FMT_I8</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Pixel format of the surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width in pixels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height in pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The initialized surface </dd></dl>

</div>
</div>
<a id="a201a14d89649b0f81ef8d535b724b34f" name="a201a14d89649b0f81ef8d535b724b34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201a14d89649b0f81ef8d535b724b34f">&#9670;&#160;</a></span>surface_make_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a> surface_make_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> structure, pointing to a rectangular portion of another surface. </p>
<p>The surface returned by this function will point to a portion of the buffer of the parent surface, and will have of course the same pixel format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>Parent surface that will be pointed to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>X coordinate of the top-left corner within the parent surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y0</td><td>Y coordinate of the top-left corner within the parent surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the surface that will be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the surface that will be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The initialized surface </dd></dl>

</div>
</div>
<a id="abb7940ed434b55044bf078472f59173e" name="abb7940ed434b55044bf078472f59173e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7940ed434b55044bf078472f59173e">&#9670;&#160;</a></span>surface_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void surface_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a> *&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the buffer allocated in a surface. </p>
<p>This function should be called after a surface allocated via <a class="el" href="surface_8h.html#a5a48f2ccc890381490463097d6f51c93" title="Allocate a new surface in memory.">surface_alloc</a> is not needed anymore.</p>
<p>Calling this function on surfaces allocated via <a class="el" href="surface_8h.html#a47bd38809ff7938c1d0123d540a2851a" title="Initialize a surface_t structure with the provided buffer.">surface_make</a> or <a class="el" href="surface_8h.html#a201a14d89649b0f81ef8d535b724b34f" title="Initialize a surface_t structure, pointing to a rectangular portion of another surface.">surface_make_sub</a> (that is, surfaces initialized with an existing buffer pointer) has no effect but clearing the contents of the surface structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>The surface to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af87295c49590f004305ce1d5e36e42f7" name="af87295c49590f004305ce1d5e36e42f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87295c49590f004305ce1d5e36e42f7">&#9670;&#160;</a></span>surface_get_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a> surface_get_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="surface_8h.html#structsurface__t">surface_t</a> *&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pixel format of a surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>Surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pixel format of the provided surface </dd></dl>

</div>
</div>
<a id="a0366404adb987076f9b28e34cc15820b" name="a0366404adb987076f9b28e34cc15820b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0366404adb987076f9b28e34cc15820b">&#9670;&#160;</a></span>surface_has_owned_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool surface_has_owned_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="surface_8h.html#structsurface__t">surface_t</a> *&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this surface owns the buffer that it contains. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>Surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this surface owns the buffer; false otherwise </dd></dl>

</div>
</div>
<a id="ade63b26694a75b09506d5fd9cf35e670" name="ade63b26694a75b09506d5fd9cf35e670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade63b26694a75b09506d5fd9cf35e670">&#9670;&#160;</a></span>surface_make_placeholder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a> surface_make_placeholder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a placeholder surface, that can be used during rdpq block recording. </p>
<p>When recording a rspq block (via <a class="el" href="rspq_8c.html#a41f292fc1f7b261f84c55fc356f86acf" title="Begin creating a new block.">rspq_block_begin</a> / <a class="el" href="rspq_8c.html#a81339d69802148a09829d1c6d9a9f9f6" title="Finish creating a block.">rspq_block_end</a>) it might be useful sometimes to issue draw commands that refer to a surface, but allowing the actual surface to change later at any time.</p>
<p>See <a class="el" href="rdpq_8c.html#ac3a157dcfb511e567251d69ba2272287" title="Store an address into the rdpq lookup table.">rdpq_set_lookup_address</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>A placeholder surface holds a NULL pointer to the actual bytes. Make sure not to use it anywhere else but with rdpq.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index that will be used to lookup the surface at playback time </td></tr>
    <tr><td class="paramname">format</td><td>Pixel format </td></tr>
    <tr><td class="paramname">width</td><td>Width of the surface in pixels </td></tr>
    <tr><td class="paramname">height</td><td>Height of the surface in pixels </td></tr>
    <tr><td class="paramname">stride</td><td>Stride of the surface in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> The initialized placeholder surface</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="surface_8h.html#a72c6f76ee9f39cc668e6628cc1fb46ef" title="Create a linear placeholder surface, that can be used during rdpq block recording.">surface_make_placeholder_linear</a> </dd>
<dd>
<a class="el" href="rdpq_8c.html#ac3a157dcfb511e567251d69ba2272287" title="Store an address into the rdpq lookup table.">rdpq_set_lookup_address</a> </dd></dl>

</div>
</div>
<a id="a72c6f76ee9f39cc668e6628cc1fb46ef" name="a72c6f76ee9f39cc668e6628cc1fb46ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c6f76ee9f39cc668e6628cc1fb46ef">&#9670;&#160;</a></span>surface_make_placeholder_linear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="surface_8h.html#structsurface__t">surface_t</a> surface_make_placeholder_linear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="surface_8h.html#a01f43f3d6c80a7658bf729bfaf3136e1">tex_format_t</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a linear placeholder surface, that can be used during rdpq block recording. </p>
<p>This function is similar to <a class="el" href="surface_8h.html#ade63b26694a75b09506d5fd9cf35e670" title="Create a placeholder surface, that can be used during rdpq block recording.">surface_make_placeholder</a>, but it creates a surface that is linearly mapped with no per-line padding or extraneous data. (so the stride is automatically deduced from the width).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index that will be used to lookup the surface at playback time </td></tr>
    <tr><td class="paramname">format</td><td>Pixel format </td></tr>
    <tr><td class="paramname">width</td><td>Width of the surface in pixels </td></tr>
    <tr><td class="paramname">height</td><td>Height of the surface in pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="surface_8h.html#structsurface__t" title="A surface buffer for graphics.">surface_t</a> The initialized placeholder surface</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="surface_8h.html#ade63b26694a75b09506d5fd9cf35e670" title="Create a placeholder surface, that can be used during rdpq block recording.">surface_make_placeholder</a> </dd></dl>

</div>
</div>
<a id="a4f3cbb3a8c49dba329cd9c816c152825" name="a4f3cbb3a8c49dba329cd9c816c152825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3cbb3a8c49dba329cd9c816c152825">&#9670;&#160;</a></span>surface_get_placeholder_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int surface_get_placeholder_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="surface_8h.html#structsurface__t">surface_t</a> *&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lookup index of a placeholder surface. </p>
<p>If the surface is a placeholder, this function returns the associated lookup index that will be used to retrieve the actual surface at playback time. Otherwise, if it is a normal surface, this function will return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>Placeholder surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The lookup index of the placeholder surface, or 0 if it is a normal surface </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 14 2024 15:41:47 for libdragon by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
